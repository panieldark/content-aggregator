"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("pages/_app",{

/***/ "./src/pages/_app.tsx":
/*!****************************!*\
  !*** ./src/pages/_app.tsx ***!
  \****************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ \"./node_modules/react/jsx-dev-runtime.js\");\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _chakra_ui_react__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @chakra-ui/react */ \"./node_modules/@chakra-ui/react/dist/index.esm.js\");\n/* harmony import */ var _theme__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../theme */ \"./src/theme.tsx\");\n/* harmony import */ var urql__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! urql */ \"./node_modules/urql/dist/urql.es.js\");\n/* harmony import */ var _urql_exchange_graphcache__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @urql/exchange-graphcache */ \"./node_modules/@urql/exchange-graphcache/dist/urql-exchange-graphcache.mjs\");\n\n\n\n\n\nconst client = (0,urql__WEBPACK_IMPORTED_MODULE_2__.createClient)({\n    url: \"http://localhost:4000/graphql\",\n    fetchOptions: {\n        credentials: \"include\"\n    },\n    exchange: [\n        urql__WEBPACK_IMPORTED_MODULE_2__.dedupExchange,\n        (0,_urql_exchange_graphcache__WEBPACK_IMPORTED_MODULE_3__.cacheExchange)(),\n        urql__WEBPACK_IMPORTED_MODULE_2__.fetchExchange\n    ]\n});\nfunction MyApp(param) {\n    let { Component , pageProps  } = param;\n    return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(urql__WEBPACK_IMPORTED_MODULE_2__.Provider, {\n        value: client,\n        children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_chakra_ui_react__WEBPACK_IMPORTED_MODULE_4__.ChakraProvider, {\n            theme: _theme__WEBPACK_IMPORTED_MODULE_1__[\"default\"],\n            children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(Component, {\n                ...pageProps\n            }, void 0, false, {\n                fileName: \"/Users/daniel.park/Dev/content-aggregator/web/src/pages/_app.tsx\",\n                lineNumber: 18,\n                columnNumber: 11\n            }, this)\n        }, void 0, false, {\n            fileName: \"/Users/daniel.park/Dev/content-aggregator/web/src/pages/_app.tsx\",\n            lineNumber: 17,\n            columnNumber: 9\n        }, this)\n    }, void 0, false, {\n        fileName: \"/Users/daniel.park/Dev/content-aggregator/web/src/pages/_app.tsx\",\n        lineNumber: 16,\n        columnNumber: 7\n    }, this);\n}\n_c = MyApp;\n/* harmony default export */ __webpack_exports__[\"default\"] = (MyApp);\nvar _c;\n$RefreshReg$(_c, \"MyApp\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports on update so we can compare the boundary\n                // signatures.\n                module.hot.dispose(function (data) {\n                    data.prevExports = currentExports;\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevExports !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevExports !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvcGFnZXMvX2FwcC50c3guanMiLCJtYXBwaW5ncyI6Ijs7Ozs7OztBQUFBO0FBQWlEO0FBRXJCO0FBRThDO0FBQ2xCO0FBRXhELE1BQU1PLFNBQVNMLGtEQUFZQSxDQUFDO0lBQUNNLEtBQUs7SUFDOUJDLGNBQWM7UUFDVkMsYUFBYTtJQUNyQjtJQUFHQyxVQUFVO1FBQUNSLCtDQUFhQTtRQUFFRyx3RUFBYUE7UUFBSUYsK0NBQWFBO0tBQUM7QUFDNUQ7QUFFQSxTQUFTUSxNQUFNLEtBQWtDLEVBQUU7UUFBcEMsRUFBRUMsVUFBUyxFQUFFQyxVQUFTLEVBQVksR0FBbEM7SUFDYixxQkFDSSw4REFBQ1QsMENBQVFBO1FBQUNVLE9BQU9SO2tCQUNmLDRFQUFDUCw0REFBY0E7WUFBQ0MsT0FBT0EsOENBQUtBO3NCQUMxQiw0RUFBQ1k7Z0JBQVcsR0FBR0MsU0FBUzs7Ozs7Ozs7Ozs7Ozs7OztBQUlsQztLQVJTRjtBQVVULCtEQUFlQSxLQUFLQSxFQUFBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL3NyYy9wYWdlcy9fYXBwLnRzeD9mOWQ2Il0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IENoYWtyYVByb3ZpZGVyIH0gZnJvbSAnQGNoYWtyYS11aS9yZWFjdCdcblxuaW1wb3J0IHRoZW1lIGZyb20gJy4uL3RoZW1lJ1xuaW1wb3J0IHsgQXBwUHJvcHMgfSBmcm9tICduZXh0L2FwcCdcbmltcG9ydCB7Y3JlYXRlQ2xpZW50LCBkZWR1cEV4Y2hhbmdlLCBmZXRjaEV4Y2hhbmdlLCBQcm92aWRlcn0gZnJvbSBcInVycWxcIjtcbmltcG9ydCB7Y2FjaGVFeGNoYW5nZX0gZnJvbSBcIkB1cnFsL2V4Y2hhbmdlLWdyYXBoY2FjaGVcIjtcblxuY29uc3QgY2xpZW50ID0gY3JlYXRlQ2xpZW50KHt1cmw6IFwiaHR0cDovL2xvY2FsaG9zdDo0MDAwL2dyYXBocWxcIixcbiAgICBmZXRjaE9wdGlvbnM6IHtcbiAgICAgICAgY3JlZGVudGlhbHM6IFwiaW5jbHVkZVwiXG59LCBleGNoYW5nZTogW2RlZHVwRXhjaGFuZ2UsIGNhY2hlRXhjaGFuZ2UoKSwgZmV0Y2hFeGNoYW5nZV1cbn0pXG5cbmZ1bmN0aW9uIE15QXBwKHsgQ29tcG9uZW50LCBwYWdlUHJvcHMgfTogQXBwUHJvcHMpIHtcbiAgcmV0dXJuIChcbiAgICAgIDxQcm92aWRlciB2YWx1ZT17Y2xpZW50fT5cbiAgICAgICAgPENoYWtyYVByb3ZpZGVyIHRoZW1lPXt0aGVtZX0+XG4gICAgICAgICAgPENvbXBvbmVudCB7Li4ucGFnZVByb3BzfSAvPlxuICAgICAgICA8L0NoYWtyYVByb3ZpZGVyPlxuICAgICAgPC9Qcm92aWRlcj5cbiAgKVxufVxuXG5leHBvcnQgZGVmYXVsdCBNeUFwcFxuIl0sIm5hbWVzIjpbIkNoYWtyYVByb3ZpZGVyIiwidGhlbWUiLCJjcmVhdGVDbGllbnQiLCJkZWR1cEV4Y2hhbmdlIiwiZmV0Y2hFeGNoYW5nZSIsIlByb3ZpZGVyIiwiY2FjaGVFeGNoYW5nZSIsImNsaWVudCIsInVybCIsImZldGNoT3B0aW9ucyIsImNyZWRlbnRpYWxzIiwiZXhjaGFuZ2UiLCJNeUFwcCIsIkNvbXBvbmVudCIsInBhZ2VQcm9wcyIsInZhbHVlIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./src/pages/_app.tsx\n"));

/***/ }),

/***/ "./node_modules/@urql/exchange-graphcache/dist/urql-exchange-graphcache.mjs":
/*!**********************************************************************************!*\
  !*** ./node_modules/@urql/exchange-graphcache/dist/urql-exchange-graphcache.mjs ***!
  \**********************************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"Store\": function() { return /* binding */ Store; },\n/* harmony export */   \"cacheExchange\": function() { return /* binding */ cacheExchange; },\n/* harmony export */   \"offlineExchange\": function() { return /* binding */ offlineExchange; },\n/* harmony export */   \"query\": function() { return /* binding */ query; },\n/* harmony export */   \"write\": function() { return /* binding */ write; }\n/* harmony export */ });\n/* harmony import */ var _urql_core__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @urql/core */ \"./node_modules/@urql/core/dist/urql-core.mjs\");\n/* harmony import */ var wonka__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! wonka */ \"./node_modules/wonka/dist/wonka.mjs\");\n/* harmony import */ var graphql__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! graphql */ \"./node_modules/graphql/index.mjs\");\n\n\n\n\n\n\nvar getName = e => e.name.value;\n\nvar getFragmentTypeName = e => e.typeCondition.name.value;\n\nvar getFieldAlias = e => e.alias ? e.alias.value : e.name.value;\n\nvar y = [];\n\nvar getSelectionSet = e => e.selectionSet ? e.selectionSet.selections : y;\n\nvar getTypeCondition = e => e.typeCondition ? e.typeCondition.name.value : null;\n\nvar isFieldNode = e => e.kind === graphql__WEBPACK_IMPORTED_MODULE_0__.Kind.FIELD;\n\nvar isInlineFragment = e => e.kind === graphql__WEBPACK_IMPORTED_MODULE_0__.Kind.INLINE_FRAGMENT;\n\nvar getFieldArguments = (e, r) => {\n  var t = null;\n  if (e.arguments) {\n    for (var i = 0, a = e.arguments.length; i < a; i++) {\n      var n = e.arguments[i];\n      var o = (0,graphql__WEBPACK_IMPORTED_MODULE_0__.valueFromASTUntyped)(n.value, r);\n      if (null != o) {\n        if (!t) {\n          t = {};\n        }\n        t[getName(n)] = o;\n      }\n    }\n  }\n  return t;\n};\n\nvar filterVariables = (e, r) => {\n  if (!r || !e.variableDefinitions) {\n    return;\n  }\n  var t = {};\n  for (var i = 0, a = e.variableDefinitions.length; i < a; i++) {\n    var n = getName(e.variableDefinitions[i].variable);\n    t[n] = r[n];\n  }\n  return t;\n};\n\nvar normalizeVariables = (e, r) => {\n  var t = {};\n  if (!r) {\n    return t;\n  }\n  if (e.variableDefinitions) {\n    for (var i = 0, a = e.variableDefinitions.length; i < a; i++) {\n      var n = e.variableDefinitions[i];\n      var o = getName(n.variable);\n      t[o] = void 0 === r[o] && n.defaultValue ? (0,graphql__WEBPACK_IMPORTED_MODULE_0__.valueFromASTUntyped)(n.defaultValue, r) : r[o];\n    }\n  }\n  for (var s in r) {\n    if (!(s in t)) {\n      t[s] = r[s];\n    }\n  }\n  return t;\n};\n\nvar h = \"\\nhttps://bit.ly/2XbVrpR#\";\n\nvar m = new Set;\n\nvar g = [];\n\nvar popDebugNode = () => g.pop();\n\nvar pushDebugNode = (e, r) => {\n  var t = \"\";\n  if (r.kind === graphql__WEBPACK_IMPORTED_MODULE_0__.Kind.INLINE_FRAGMENT) {\n    t = e ? `Inline Fragment on \"${e}\"` : \"Inline Fragment\";\n  } else if (r.kind === graphql__WEBPACK_IMPORTED_MODULE_0__.Kind.OPERATION_DEFINITION) {\n    t = `${r.name ? `\"${r.name.value}\"` : \"Unnamed\"} ${r.operation}`;\n  } else if (r.kind === graphql__WEBPACK_IMPORTED_MODULE_0__.Kind.FRAGMENT_DEFINITION) {\n    t = `\"${r.name.value}\" Fragment`;\n  }\n  if (t) {\n    g.push(t);\n  }\n};\n\nvar getDebugOutput = () => g.length ? \"\\n(Caused At: \" + g.join(\", \") + \")\" : \"\";\n\nfunction invariant(e, r, t) {\n  if (!e) {\n    var i = r || \"Minfied Error #\" + t + \"\\n\";\n    if (true) {\n      i += getDebugOutput();\n    }\n    var a = new Error(i + h + t);\n    a.name = \"Graphcache Error\";\n    throw a;\n  }\n}\n\nfunction warn(e, r) {\n  if (!m.has(e)) {\n    console.warn(e + getDebugOutput() + h + r);\n    m.add(e);\n  }\n}\n\nvar getMainOperation = e => {\n  for (var r = 0; r < e.definitions.length; r++) {\n    if (e.definitions[r].kind === graphql__WEBPACK_IMPORTED_MODULE_0__.Kind.OPERATION_DEFINITION) {\n      return e.definitions[r];\n    }\n  }\n  invariant(!1,  true ? \"Invalid GraphQL document: All GraphQL documents must contain an OperationDefinitionnode for a query, subscription, or mutation.\" : 0, 1);\n};\n\nvar getFragments = e => {\n  var r = {};\n  for (var t = 0; t < e.definitions.length; t++) {\n    var i = e.definitions[t];\n    if (i.kind === graphql__WEBPACK_IMPORTED_MODULE_0__.Kind.FRAGMENT_DEFINITION) {\n      r[getName(i)] = i;\n    }\n  }\n  return r;\n};\n\nvar shouldInclude = (e, r) => {\n  for (var t = 0; e.directives && t < e.directives.length; t++) {\n    var i = e.directives[t];\n    var a = getName(i);\n    if ((\"include\" === a || \"skip\" === a) && i.arguments && i.arguments[0] && \"if\" === getName(i.arguments[0])) {\n      var n = (0,graphql__WEBPACK_IMPORTED_MODULE_0__.valueFromASTUntyped)(i.arguments[0].value, r);\n      return \"include\" === a ? !!n : !n;\n    }\n  }\n  return !0;\n};\n\nvar isDeferred = (e, r) => {\n  for (var t = 0; e.directives && t < e.directives.length; t++) {\n    var i = e.directives[t];\n    if (\"defer\" === getName(i)) {\n      for (var a = 0; i.arguments && a < i.arguments.length; a++) {\n        var n = i.arguments[t];\n        if (\"if\" === getName(n)) {\n          return !!(0,graphql__WEBPACK_IMPORTED_MODULE_0__.valueFromASTUntyped)(n.value, r);\n        }\n      }\n      return !0;\n    }\n  }\n  return !1;\n};\n\nvar isFieldNullable = (e, r, t) => {\n  var i = getField(e, r, t);\n  return !!i && \"NON_NULL\" !== i.type.kind;\n};\n\nvar isListNullable = (e, r, t) => {\n  var i = getField(e, r, t);\n  if (!i) {\n    return !1;\n  }\n  var a = \"NON_NULL\" === i.type.kind ? i.type.ofType : i.type;\n  return \"LIST\" === a.kind && \"NON_NULL\" !== a.ofType.kind;\n};\n\nvar isFieldAvailableOnType = (e, r, t) => 0 === t.indexOf(\"__\") || 0 === r.indexOf(\"__\") || !!getField(e, r, t);\n\nvar isInterfaceOfType = (e, r, t) => {\n  if (!t) {\n    return !1;\n  }\n  var i = getTypeCondition(r);\n  if (!i || t === i) {\n    return !0;\n  } else if (e.types.has(i) && \"OBJECT\" === e.types.get(i).kind) {\n    return i === t;\n  }\n  !function expectAbstractType(e, r) {\n    invariant(e.types.has(r) && (\"INTERFACE\" === e.types.get(r).kind || \"UNION\" === e.types.get(r).kind),  true ? \"Invalid Abstract type: The type `\" + r + \"` is not an Interface or Union type in the defined schema, but a fragment in the GraphQL document is using it as a type condition.\" : 0, 5);\n  }(e, i);\n  expectObjectType(e, t);\n  return e.isSubType(i, t);\n};\n\nvar getField = (e, r, t) => {\n  if (0 === t.indexOf(\"__\") || 0 === r.indexOf(\"__\")) {\n    return;\n  }\n  expectObjectType(e, r);\n  var i = e.types.get(r).fields()[t];\n  if (true) {\n    if (!i) {\n      warn(\"Invalid field: The field `\" + t + \"` does not exist on `\" + r + \"`, but the GraphQL document expects it to exist.\\nTraversal will continue, however this may lead to undefined behavior!\", 4);\n    }\n  }\n  return i;\n};\n\nfunction expectObjectType(e, r) {\n  invariant(e.types.has(r) && \"OBJECT\" === e.types.get(r).kind,  true ? \"Invalid Object type: The type `\" + r + \"` is not an object in the defined schema, but the GraphQL document is traversing it.\" : 0, 3);\n}\n\nfunction warnAboutResolver(e) {\n   true && warn(`Invalid resolver: \\`${e}\\` is not in the defined schema, but the \\`resolvers\\` option is referencing it.`, 23);\n}\n\nvar keyOfField = (r, t) => t ? `${r}(${(0,_urql_core__WEBPACK_IMPORTED_MODULE_1__.stringifyVariables)(t)})` : r;\n\nvar joinKeys = (e, r) => `${e}.${r}`;\n\nvar fieldInfoOfKey = e => {\n  var r = e.indexOf(\"(\");\n  if (r > -1) {\n    return {\n      fieldKey: e,\n      fieldName: e.slice(0, r),\n      arguments: JSON.parse(e.slice(r + 1, -1))\n    };\n  } else {\n    return {\n      fieldKey: e,\n      fieldName: e,\n      arguments: null\n    };\n  }\n};\n\nvar deserializeKeyInfo = e => {\n  var r = e.indexOf(\".\");\n  return {\n    entityKey: e.slice(0, r).replace(/%2e/g, \".\"),\n    fieldKey: e.slice(r + 1)\n  };\n};\n\nvar makeDict = () => Object.create(null);\n\nvar _ = null;\n\nvar N = null;\n\nvar k = null;\n\nvar E = null;\n\nvar O = null;\n\nvar w = null;\n\nvar b = !1;\n\nvar makeData = e => {\n  var r;\n  if (e) {\n    if (_.has(e)) {\n      return e;\n    }\n    r = N.get(e) || {\n      ...e\n    };\n    N.set(e, r);\n  } else {\n    r = {};\n  }\n  _.add(r);\n  return r;\n};\n\nvar ownsData = e => !!e && _.has(e);\n\nvar initDataState = (e, r, t, i) => {\n  _ = new WeakSet;\n  N = new WeakMap;\n  k = e;\n  E = r;\n  O = new Set;\n  b = !!i;\n  if (true) {\n    g.length = 0;\n  }\n  if (!t) {\n    w = null;\n  } else if (\"read\" === k) {\n    w = t;\n  } else if (i || r.optimisticOrder.length > 1) {\n    if (!i && !r.commutativeKeys.has(t)) {\n      reserveLayer(r, t);\n    } else if (i) {\n      if (-1 !== r.optimisticOrder.indexOf(t) && !r.commutativeKeys.has(t)) {\n        r.optimisticOrder.splice(r.optimisticOrder.indexOf(t), 1);\n      }\n      r.commutativeKeys.delete(t);\n    }\n    w = t;\n    createLayer(r, t);\n  } else {\n    w = null;\n    deleteLayer(r, t);\n  }\n};\n\nvar clearDataState = () => {\n  if (true) {\n    getCurrentDependencies();\n  }\n  var e = E;\n  var r = w;\n  b = !1;\n  w = null;\n  if (r && e.optimisticOrder.indexOf(r) > -1) {\n    var t = e.optimisticOrder.length;\n    while (--t >= 0 && e.refLock.has(e.optimisticOrder[t]) && e.commutativeKeys.has(e.optimisticOrder[t]) && !e.deferredKeys.has(e.optimisticOrder[t])) {\n      squashLayer(e.optimisticOrder[t]);\n    }\n  }\n  _ = null;\n  N = null;\n  k = null;\n  E = null;\n  O = null;\n  if (true) {\n    g.length = 0;\n  }\n  if ( true && !e.defer) {\n    e.defer = !0;\n    setTimeout((() => {\n      initDataState(\"read\", e, null);\n      gc();\n      persistData();\n      clearDataState();\n      e.defer = !1;\n    }));\n  }\n};\n\nvar noopDataState = (e, r, t) => {\n  if (r && !t) {\n    e.deferredKeys.delete(r);\n  }\n  initDataState(\"write\", e, r, t);\n  clearDataState();\n};\n\nvar getCurrentOperation = () => {\n  invariant(null !== k,  true ? \"Invalid Cache call: The cache may only be accessed or mutated duringoperations like write or query, or as part of its resolvers, updaters, or optimistic configs.\" : 0, 2);\n  return k;\n};\n\nvar getCurrentDependencies = () => {\n  invariant(null !== O,  true ? \"Invalid Cache call: The cache may only be accessed or mutated duringoperations like write or query, or as part of its resolvers, updaters, or optimistic configs.\" : 0, 2);\n  return O;\n};\n\nvar setNode = (e, r, t, i) => {\n  var a = w ? e.optimistic.get(w) : e.base;\n  var n = a.get(r);\n  if (void 0 === n) {\n    a.set(r, n = makeDict());\n  }\n  if (void 0 === i && !w) {\n    delete n[t];\n  } else {\n    n[t] = i;\n  }\n};\n\nvar getNode = (e, r, t) => {\n  var i;\n  var a = !b && \"read\" === k && w && E.commutativeKeys.has(w);\n  for (var n = 0, o = E.optimisticOrder.length; n < o; n++) {\n    var s = E.optimisticOrder[n];\n    var v = e.optimistic.get(s);\n    a = a && s !== w;\n    if (v && (!a || !E.commutativeKeys.has(s)) && (!b || \"write\" === k || E.commutativeKeys.has(s)) && void 0 !== (i = v.get(r)) && t in i) {\n      return i[t];\n    }\n  }\n  return void 0 !== (i = e.base.get(r)) ? i[t] : void 0;\n};\n\nvar updateRCForEntity = (e, r, t, i) => {\n  var a = r.get(t) || 0;\n  var n = a + i;\n  r.set(t, n);\n  if (e) {\n    if (n <= 0) {\n      e.add(t);\n    } else if (a <= 0 && n > 0) {\n      e.delete(t);\n    }\n  }\n};\n\nvar updateRCForLink = (e, r, t, i) => {\n  if (\"string\" == typeof t) {\n    updateRCForEntity(e, r, t, i);\n  } else if (Array.isArray(t)) {\n    for (var a = 0, n = t.length; a < n; a++) {\n      if (Array.isArray(t[a])) {\n        updateRCForLink(e, r, t[a], i);\n      } else if (t[a]) {\n        updateRCForEntity(e, r, t[a], i);\n      }\n    }\n  }\n};\n\nvar extractNodeFields = (e, r, t) => {\n  if (void 0 !== t) {\n    for (var i in t) {\n      if (!r.has(i)) {\n        e.push(fieldInfoOfKey(i));\n        r.add(i);\n      }\n    }\n  }\n};\n\nvar extractNodeMapFields = (e, r, t, i) => {\n  extractNodeFields(e, r, i.base.get(t));\n  for (var a = 0, n = E.optimisticOrder.length; a < n; a++) {\n    var o = i.optimistic.get(E.optimisticOrder[a]);\n    if (void 0 !== o) {\n      extractNodeFields(e, r, o.get(t));\n    }\n  }\n};\n\nvar gc = () => {\n  var {gc: e} = E;\n  for (var r of e.keys()) {\n    if ((E.refCount.get(r) || 0) > 0) {\n      e.delete(r);\n      return;\n    }\n    for (var t of E.refLock.keys()) {\n      var i = E.refLock.get(t);\n      if (i) {\n        if ((i.get(r) || 0) > 0) {\n          return;\n        }\n        i.delete(r);\n      }\n    }\n    E.refCount.delete(r);\n    e.delete(r);\n    E.records.base.delete(r);\n    var a = E.links.base.get(r);\n    if (a) {\n      E.links.base.delete(r);\n      for (var n in a) {\n        updateRCForLink(e, E.refCount, a[n], -1);\n      }\n    }\n  }\n};\n\nvar updateDependencies = (e, r) => {\n  if (\"__typename\" !== r) {\n    if (e !== E.queryRootKey) {\n      O.add(e);\n    } else if (void 0 !== r) {\n      O.add(joinKeys(e, r));\n    }\n  }\n};\n\nvar updatePersist = (e, r) => {\n  if (!b && E.storage) {\n    E.persist.add(((e, r) => `${e.replace(/\\./g, \"%2e\")}.${r}`)(e, r));\n  }\n};\n\nvar readRecord = (e, r) => {\n  updateDependencies(e, r);\n  return getNode(E.records, e, r);\n};\n\nvar readLink = (e, r) => {\n  updateDependencies(e, r);\n  return getNode(E.links, e, r);\n};\n\nvar writeRecord = (e, r, t) => {\n  updateDependencies(e, r);\n  updatePersist(e, r);\n  setNode(E.records, e, r, t);\n};\n\nvar writeLink = (e, r, t) => {\n  var i = E;\n  var a;\n  var n;\n  var o;\n  if (w) {\n    if (!(a = i.refLock.get(w))) {\n      i.refLock.set(w, a = new Map);\n    }\n    n = i.links.optimistic.get(w);\n  } else {\n    a = i.refCount;\n    n = i.links.base;\n    o = i.gc;\n  }\n  var s = n && n.get(e);\n  var v = s && s[r];\n  updateDependencies(e, r);\n  updatePersist(e, r);\n  setNode(i.links, e, r, t);\n  updateRCForLink(o, a, v, -1);\n  updateRCForLink(o, a, t, 1);\n};\n\nvar reserveLayer = (e, r, t) => {\n  if (t) {\n    e.deferredKeys.add(r);\n  } else {\n    e.deferredKeys.delete(r);\n  }\n  var i = e.optimisticOrder.indexOf(r);\n  if (i > -1) {\n    if (!e.commutativeKeys.has(r) && !t) {\n      e.optimisticOrder.splice(i, 1);\n      clearLayer(e, r);\n    } else {\n      return;\n    }\n  }\n  for (i = 0; t && i < e.optimisticOrder.length && !e.deferredKeys.has(e.optimisticOrder[i]) && (!e.refLock.has(e.optimisticOrder[i]) || !e.commutativeKeys.has(e.optimisticOrder[i])); i++) {}\n  e.optimisticOrder.splice(i, 0, r);\n  e.commutativeKeys.add(r);\n};\n\nvar createLayer = (e, r) => {\n  if (-1 === e.optimisticOrder.indexOf(r)) {\n    e.optimisticOrder.unshift(r);\n  }\n  if (!e.refLock.has(r)) {\n    e.refLock.set(r, new Map);\n    e.links.optimistic.set(r, new Map);\n    e.records.optimistic.set(r, new Map);\n  }\n};\n\nvar clearLayer = (e, r) => {\n  if (e.refLock.has(r)) {\n    e.refLock.delete(r);\n    e.records.optimistic.delete(r);\n    e.links.optimistic.delete(r);\n    e.deferredKeys.delete(r);\n  }\n};\n\nvar deleteLayer = (e, r) => {\n  var t = e.optimisticOrder.indexOf(r);\n  if (t > -1) {\n    e.optimisticOrder.splice(t, 1);\n    e.commutativeKeys.delete(r);\n  }\n  clearLayer(e, r);\n};\n\nvar squashLayer = e => {\n  var r = O;\n  O = new Set;\n  var t = E.links.optimistic.get(e);\n  if (t) {\n    for (var i of t.entries()) {\n      var a = i[0];\n      var n = i[1];\n      for (var o in n) {\n        writeLink(a, o, n[o]);\n      }\n    }\n  }\n  var s = E.records.optimistic.get(e);\n  if (s) {\n    for (var v of s.entries()) {\n      var l = v[0];\n      var u = v[1];\n      for (var d in u) {\n        writeRecord(l, d, u[d]);\n      }\n    }\n  }\n  O = r;\n  deleteLayer(E, e);\n};\n\nvar inspectFields = e => {\n  var {links: r, records: t} = E;\n  var i = [];\n  var a = new Set;\n  updateDependencies(e);\n  extractNodeMapFields(i, a, e, r);\n  extractNodeMapFields(i, a, e, t);\n  return i;\n};\n\nvar persistData = () => {\n  if (E.storage) {\n    b = !0;\n    k = \"read\";\n    var r = makeDict();\n    for (var t of E.persist.keys()) {\n      var {entityKey: i, fieldKey: a} = deserializeKeyInfo(t);\n      var n = void 0;\n      if (void 0 !== (n = readLink(i, a))) {\n        r[t] = `:${(0,_urql_core__WEBPACK_IMPORTED_MODULE_1__.stringifyVariables)(n)}`;\n      } else if (void 0 !== (n = readRecord(i, a))) {\n        r[t] = (0,_urql_core__WEBPACK_IMPORTED_MODULE_1__.stringifyVariables)(n);\n      } else {\n        r[t] = void 0;\n      }\n    }\n    b = !1;\n    E.storage.writeData(r);\n    E.persist.clear();\n  }\n};\n\nvar D = {\n  current: null\n};\n\nvar q = {\n  current: !1\n};\n\nvar getFieldError = e => e.__internal.path.length > 0 && e.__internal.errorMap ? e.__internal.errorMap[e.__internal.path.join(\".\")] : void 0;\n\nvar makeContext = (e, r, t, i, a, n, o) => {\n  var s = {\n    store: e,\n    variables: r,\n    fragments: t,\n    parent: {\n      __typename: i\n    },\n    parentTypeName: i,\n    parentKey: a,\n    parentFieldKey: \"\",\n    fieldName: \"\",\n    error: void 0,\n    partial: !1,\n    optimistic: !!n,\n    __internal: {\n      path: [],\n      errorMap: void 0\n    }\n  };\n  if (o && o.graphQLErrors) {\n    for (var v = 0; v < o.graphQLErrors.length; v++) {\n      var l = o.graphQLErrors[v];\n      if (l.path && l.path.length) {\n        if (!s.__internal.errorMap) {\n          s.__internal.errorMap = Object.create(null);\n        }\n        s.__internal.errorMap[l.path.join(\".\")] = l;\n      }\n    }\n  }\n  return s;\n};\n\nvar updateContext = (e, r, t, i, a, n) => {\n  D.current = e;\n  e.parent = r;\n  e.parentTypeName = t;\n  e.parentKey = i;\n  e.parentFieldKey = a;\n  e.fieldName = n;\n  e.error = getFieldError(e);\n};\n\nvar isFragmentHeuristicallyMatching = (e, r, t, i) => {\n  if (!r) {\n    return !1;\n  }\n  var a = getTypeCondition(e);\n  if (!a || r === a) {\n    return !0;\n  }\n   true && warn(\"Heuristic Fragment Matching: A fragment is trying to match against the `\" + r + \"` type, but the type condition is `\" + a + \"`. Since GraphQL allows for interfaces `\" + a + \"` may be aninterface.\\nA schema needs to be defined for this match to be deterministic, otherwise the fragment will be matched heuristically!\", 16);\n  return \"write\" === k || !getSelectionSet(e).some((e => {\n    if (!isFieldNode(e)) {\n      return !1;\n    }\n    var r = keyOfField(getName(e), getFieldArguments(e, i));\n    return !((e, r) => void 0 !== readRecord(e, r) || void 0 !== readLink(e, r))(t, r);\n  }));\n};\n\nvar makeSelectionIterator = (e, r, t, i) => {\n  var a = !1;\n  var n;\n  var o = 0;\n  return function next() {\n    if (!q.current && a) {\n      q.current = a;\n    }\n    if (n) {\n      var s = n();\n      if (null != s) {\n        return s;\n      }\n      n = void 0;\n      a = !1;\n      if (true) {\n        popDebugNode();\n      }\n    }\n    while (o < t.length) {\n      var v = t[o++];\n      if (!shouldInclude(v, i.variables)) {\n        continue;\n      } else if (!isFieldNode(v)) {\n        var l = !isInlineFragment(v) ? i.fragments[getName(v)] : v;\n        if (void 0 !== l) {\n          if (i.store.schema ? isInterfaceOfType(i.store.schema, l, e) : isFragmentHeuristicallyMatching(l, e, r, i.variables)) {\n            if (true) {\n              pushDebugNode(e, l);\n            }\n            a = !!isDeferred(v, i.variables);\n            if (!q.current && a) {\n              q.current = a;\n            }\n            return (n = makeSelectionIterator(e, r, getSelectionSet(l), i))();\n          }\n        }\n      } else {\n        return v;\n      }\n    }\n  };\n};\n\nvar ensureData = e => null == e ? null : e;\n\nvar ensureLink = (e, r) => {\n  if (null == r) {\n    return r;\n  } else if (Array.isArray(r)) {\n    var t = new Array(r.length);\n    for (var i = 0, a = t.length; i < a; i++) {\n      t[i] = ensureLink(e, r[i]);\n    }\n    return t;\n  }\n  var n = e.keyOfEntity(r);\n  if (true) {\n    if (!n && r && \"object\" == typeof r) {\n      warn(\"Can't generate a key for link(...) item.\\nYou have to pass an `id` or `_id` field or create a custom `keys` config for `\" + r.__typename + \"`.\", 12);\n    }\n  }\n  return n;\n};\n\nvar write = (e, r, t, i, a) => {\n  initDataState(\"write\", e.data, a || null);\n  var n = startWrite(e, r, t, i);\n  clearDataState();\n  return n;\n};\n\nvar startWrite = (e, r, t, i, a) => {\n  var n = getMainOperation(r.query);\n  var o = {\n    data: t,\n    dependencies: getCurrentDependencies()\n  };\n  var s = e.rootFields[n.operation];\n  var v = makeContext(e, normalizeVariables(n, r.variables), getFragments(r.query), s, s, !!a, i);\n  if (true) {\n    pushDebugNode(s, n);\n  }\n  writeSelection(v, s, getSelectionSet(n), t);\n  if (true) {\n    popDebugNode();\n  }\n  return o;\n};\n\nvar writeSelection = (e, r, t, i) => {\n  var a = r === e.store.rootFields.query;\n  var n = !a && !!e.store.rootNames[r];\n  var o = n || a ? r : i.__typename;\n  if (!o) {\n     true && warn(\"Couldn't find __typename when writing.\\nIf you're writing to the cache manually have to pass a `__typename` property on each entity in your data.\", 14);\n    return;\n  } else if (!n && !a && r) {\n    writeRecord(r, \"__typename\", o);\n  }\n  var s = makeSelectionIterator(o, r || o, t, e);\n  var v;\n  while (v = s()) {\n    var l = getName(v);\n    var u = getFieldArguments(v, e.variables);\n    var d = keyOfField(l, u);\n    var p = getFieldAlias(v);\n    var c = i[e.optimistic ? l : p];\n    if (true) {\n      if (!n && void 0 === c && !q.current && !e.optimistic) {\n         true && warn(\"Invalid undefined: The field at `\" + d + \"` is `undefined`, but the GraphQL query expects a \" + (void 0 === v.selectionSet ? \"scalar (number, boolean, etc)\" : \"selection set\") + \" for this field.\", 13);\n        continue;\n      } else if (e.store.schema && o && \"__typename\" !== l) {\n        isFieldAvailableOnType(e.store.schema, o, l);\n      }\n    }\n    if (\"__typename\" === l || void 0 === c && (q.current || e.optimistic && !n)) {\n      continue;\n    }\n    e.__internal.path.push(p);\n    var f = void 0;\n    if (e.optimistic && n) {\n      if (!(f = e.store.optimisticMutations[l])) {\n        continue;\n      }\n    } else if (e.optimistic && \"function\" == typeof c) {\n      f = c;\n    }\n    if (f) {\n      updateContext(e, i, o, o, d, l);\n      c = ensureData(f(u || {}, e.store, e));\n    }\n    if (v.selectionSet) {\n      if (r && !n) {\n        var y = joinKeys(r, d);\n        var h = writeField(e, getSelectionSet(v), ensureData(c), y);\n        writeLink(r || o, d, h);\n      } else {\n        writeField(e, getSelectionSet(v), ensureData(c));\n      }\n    } else if (r && !n) {\n      writeRecord(r || o, d, null !== c || !getFieldError(e) ? c : void 0);\n    }\n    if (n) {\n      var m = e.store.updates[o][l];\n      if (m) {\n        updateContext(e, i, o, o, joinKeys(o, d), l);\n        i[l] = c;\n        m(i, u || {}, e.store, e);\n      }\n    }\n    e.__internal.path.pop();\n  }\n};\n\nvar V = /^__|PageInfo|(Connection|Edge)$/;\n\nvar writeField = (e, r, t, i) => {\n  if (Array.isArray(t)) {\n    var a = new Array(t.length);\n    for (var n = 0, o = t.length; n < o; n++) {\n      e.__internal.path.push(n);\n      var s = i ? joinKeys(i, `${n}`) : void 0;\n      var v = writeField(e, r, t[n], s);\n      a[n] = v;\n      e.__internal.path.pop();\n    }\n    return a;\n  } else if (null === t) {\n    return getFieldError(e) ? void 0 : null;\n  }\n  var l = e.store.keyOfEntity(t);\n  var u = t.__typename;\n  if (true) {\n    if (i && !e.store.keys[t.__typename] && null === l && \"string\" == typeof u && !V.test(u)) {\n      warn(\"Invalid key: The GraphQL query at the field at `\" + i + \"` has a selection set, but no key could be generated for the data at this field.\\nYou have to request `id` or `_id` fields for all selection sets or create a custom `keys` config for `\" + u + \"`.\\nEntities without keys will be embedded directly on the parent entity. If this is intentional, create a `keys` config for `\" + u + \"` that always returns null.\", 15);\n    }\n  }\n  var d = l || i;\n  writeSelection(e, d, r, t);\n  return d || null;\n};\n\nclass Store {\n  constructor(e) {\n    Store.prototype.__init.call(this);\n    Store.prototype.__init2.call(this);\n    if (!e) {\n      e = {};\n    }\n    this.resolvers = e.resolvers || {};\n    this.optimisticMutations = e.optimistic || {};\n    this.keys = e.keys || {};\n    var r = \"Query\";\n    var t = \"Mutation\";\n    var i = \"Subscription\";\n    if (e.schema) {\n      var a = (({__schema: e}) => {\n        var r = new Map;\n        var buildNameMap = e => {\n          var r;\n          return () => {\n            if (!r) {\n              r = {};\n              for (var t = 0; t < e.length; t++) {\n                r[e[t].name] = e[t];\n              }\n            }\n            return r;\n          };\n        };\n        var buildType = e => {\n          switch (e.kind) {\n           case \"OBJECT\":\n           case \"INTERFACE\":\n            return {\n              name: e.name,\n              kind: e.kind,\n              interfaces: buildNameMap(e.interfaces || []),\n              fields: buildNameMap(e.fields.map((e => ({\n                name: e.name,\n                type: e.type,\n                args: buildNameMap(e.args)\n              }))))\n            };\n\n           case \"UNION\":\n            return {\n              name: e.name,\n              kind: e.kind,\n              types: buildNameMap(e.possibleTypes || [])\n            };\n          }\n        };\n        var t = {\n          query: e.queryType ? e.queryType.name : null,\n          mutation: e.mutationType ? e.mutationType.name : null,\n          subscription: e.subscriptionType ? e.subscriptionType.name : null,\n          types: void 0,\n          isSubType(e, t) {\n            var i = r.get(e);\n            var a = r.get(t);\n            if (!i || !a) {\n              return !1;\n            } else if (\"UNION\" === i.kind) {\n              return !!i.types()[t];\n            } else if (\"OBJECT\" !== i.kind && \"OBJECT\" === a.kind) {\n              return !!a.interfaces()[e];\n            } else {\n              return e === t;\n            }\n          }\n        };\n        if (e.types) {\n          t.types = r;\n          for (var i = 0; i < e.types.length; i++) {\n            var a = e.types[i];\n            if (a && a.name) {\n              var n = buildType(a);\n              if (n) {\n                r.set(a.name, n);\n              }\n            }\n          }\n        }\n        return t;\n      })(e.schema);\n      r = a.query || r;\n      t = a.mutation || t;\n      i = a.subscription || i;\n      if (a.types) {\n        this.schema = a;\n      }\n    }\n    this.updates = {\n      [t]: e.updates && e.updates.Mutation || {},\n      [i]: e.updates && e.updates.Subscription || {}\n    };\n    this.rootFields = {\n      query: r,\n      mutation: t,\n      subscription: i\n    };\n    this.rootNames = {\n      [r]: \"query\",\n      [t]: \"mutation\",\n      [i]: \"subscription\"\n    };\n    this.data = (n = r, {\n      defer: !1,\n      gc: new Set,\n      persist: new Set,\n      queryRootKey: n,\n      refCount: new Map,\n      refLock: new Map,\n      links: {\n        optimistic: new Map,\n        base: new Map\n      },\n      records: {\n        optimistic: new Map,\n        base: new Map\n      },\n      deferredKeys: new Set,\n      commutativeKeys: new Set,\n      optimisticOrder: [],\n      storage: null\n    });\n    var n;\n    if (this.schema && \"production\" !== \"development\") {\n      !function expectValidKeyingConfig(e, r) {\n        if (true) {\n          for (var t in r) {\n            if (true) {\n              if (!e.types.has(t)) {\n                warn(\"Invalid Object type: The type `\" + t + \"` is not an object in the defined schema, but the `keys` option is referencing it.\", 20);\n              }\n            }\n          }\n        }\n      }(this.schema, this.keys);\n      !function expectValidUpdatesConfig(e, r) {\n        if (false) {}\n        if (e.mutation) {\n          var t = e.types.get(e.mutation).fields();\n          var i = r[e.mutation] || {};\n          for (var a in i) {\n            if (true) {\n              if (void 0 === t[a]) {\n                warn(\"Invalid mutation field: `\" + a + \"` is not in the defined schema, but the `updates.Mutation` option is referencing it.\", 21);\n              }\n            }\n          }\n        }\n        if (e.subscription) {\n          var n = e.types.get(e.subscription).fields();\n          var o = r[e.subscription] || {};\n          for (var s in o) {\n            if (true) {\n              if (void 0 === n[s]) {\n                warn(\"Invalid subscription field: `\" + s + \"` is not in the defined schema, but the `updates.Subscription` option is referencing it.\", 22);\n              }\n            }\n          }\n        }\n      }(this.schema, this.updates);\n      !function expectValidResolversConfig(e, r) {\n        if (false) {}\n        for (var t in r) {\n          if (\"Query\" === t) {\n            if (e.query) {\n              var i = e.types.get(e.query).fields();\n              for (var a in r.Query) {\n                if (!i[a]) {\n                  warnAboutResolver(\"Query.\" + a);\n                }\n              }\n            } else {\n              warnAboutResolver(\"Query\");\n            }\n          } else if (!e.types.has(t)) {\n            warnAboutResolver(t);\n          } else if (\"INTERFACE\" === e.types.get(t).kind || \"UNION\" === e.types.get(t).kind) {\n            s = t, v = e.types.get(t).kind,  true && warn(`Invalid resolver: \\`${s}\\` does not match to a concrete type in the schema, but the \\`resolvers\\` option is referencing it. Implement the resolver for the types that ${\"UNION\" === v ? \"make up the union\" : \"implement the interface\"} instead.`, 26);\n          } else {\n            var n = e.types.get(t).fields();\n            for (var o in r[t]) {\n              if (!n[o]) {\n                warnAboutResolver(t + \".\" + o);\n              }\n            }\n          }\n        }\n        var s, v;\n      }(this.schema, this.resolvers);\n      !function expectValidOptimisticMutationsConfig(e, r) {\n        if (false) {}\n        if (e.mutation) {\n          var t = e.types.get(e.mutation).fields();\n          for (var i in r) {\n            if (true) {\n              if (!t[i]) {\n                warn(`Invalid optimistic mutation field: \\`${i}\\` is not a mutation field in the defined schema, but the \\`optimistic\\` option is referencing it.`, 24);\n              }\n            }\n          }\n        }\n      }(this.schema, this.optimisticMutations);\n    }\n  }\n  __init() {\n    this.keyOfField = keyOfField;\n  }\n  keyOfEntity(e) {\n    if (D.current && e === D.current.parent) {\n      return D.current.parentKey;\n    }\n    if (null == e || \"string\" == typeof e) {\n      return e || null;\n    }\n    if (!e.__typename) {\n      return null;\n    }\n    if (this.rootNames[e.__typename]) {\n      return e.__typename;\n    }\n    var r;\n    if (this.keys[e.__typename]) {\n      r = this.keys[e.__typename](e);\n    } else if (null != e.id) {\n      r = `${e.id}`;\n    } else if (null != e._id) {\n      r = `${e._id}`;\n    }\n    return r ? `${e.__typename}:${r}` : null;\n  }\n  resolve(e, r, t) {\n    var i = keyOfField(r, t);\n    var a = this.keyOfEntity(e);\n    if (!a) {\n      return null;\n    }\n    var n = readRecord(a, i);\n    if (void 0 !== n) {\n      return n;\n    }\n    return readLink(a, i) || null;\n  }\n  __init2() {\n    this.resolveFieldByKey = this.resolve;\n  }\n  invalidate(e, r, t) {\n    var i = this.keyOfEntity(e);\n    invariant(i,  true ? \"Can't generate a key for invalidate(...).\\nYou have to pass an id or _id field or create a custom `keys` field for `\" + typeof e == \"object\" ? e.__typename : e + \"`.\" : 0, 19);\n    ((e, r, t) => {\n      var i = r ? [ {\n        fieldKey: keyOfField(r, t)\n      } ] : inspectFields(e);\n      for (var a = 0, n = i.length; a < n; a++) {\n        var {fieldKey: o} = i[a];\n        if (void 0 !== readLink(e, o)) {\n          writeLink(e, o, void 0);\n        } else {\n          writeRecord(e, o, void 0);\n        }\n      }\n    })(i, r, t);\n  }\n  inspectFields(e) {\n    var r = this.keyOfEntity(e);\n    return r ? inspectFields(r) : [];\n  }\n  updateQuery(e, i) {\n    var a = (0,_urql_core__WEBPACK_IMPORTED_MODULE_1__.createRequest)(e.query, e.variables);\n    a.query = (0,_urql_core__WEBPACK_IMPORTED_MODULE_1__.formatDocument)(a.query);\n    var n = i(this.readQuery(a));\n    if (null !== n) {\n      startWrite(this, a, n);\n    }\n  }\n  readQuery(e) {\n    var i = (0,_urql_core__WEBPACK_IMPORTED_MODULE_1__.createRequest)(e.query, e.variables);\n    i.query = (0,_urql_core__WEBPACK_IMPORTED_MODULE_1__.formatDocument)(i.query);\n    return read(this, i).data;\n  }\n  readFragment(e, r, i, a) {\n    return readFragment(this, (0,_urql_core__WEBPACK_IMPORTED_MODULE_1__.formatDocument)(e), r, i, a);\n  }\n  writeFragment(e, r, i, a) {\n    ((e, r, t, i, a) => {\n      var n = getFragments(r);\n      var o;\n      if (a) {\n        if (!(o = n[a])) {\n           true && warn(\"writeFragment(...) was called with a fragment name that does not exist.\\nYou provided \" + a + \" but could only find \" + Object.keys(n).join(\", \") + \".\", 11);\n          return null;\n        }\n      } else if (!(o = n[Object.keys(n)[0]])) {\n         true && warn(\"writeFragment(...) was called with an empty fragment.\\nYou have to call it with at least one fragment in your GraphQL document.\", 11);\n        return null;\n      }\n      var s = getFragmentTypeName(o);\n      var v = {\n        __typename: s,\n        ...t\n      };\n      var l = e.keyOfEntity(v);\n      if (!l) {\n        return  true ? warn(\"Can't generate a key for writeFragment(...) data.\\nYou have to pass an `id` or `_id` field or create a custom `keys` config for `\" + s + \"`.\", 12) : 0;\n      }\n      if (true) {\n        pushDebugNode(s, o);\n      }\n      var u = makeContext(e, i || {}, n, s, l, void 0);\n      writeSelection(u, l, getSelectionSet(o), v);\n      if (true) {\n        popDebugNode();\n      }\n    })(this, (0,_urql_core__WEBPACK_IMPORTED_MODULE_1__.formatDocument)(e), r, i, a);\n  }\n  link(e, r, t, i) {\n    var a = void 0 !== i ? t : null;\n    var n = void 0 !== i ? i : t;\n    var o = ensureLink(this, e);\n    if (\"string\" == typeof o) {\n      writeLink(o, keyOfField(r, a), ensureLink(this, n));\n    }\n  }\n}\n\nvar query = (e, r, t, i, a) => {\n  initDataState(\"read\", e.data, a);\n  var n = read(e, r, t, i);\n  clearDataState();\n  return n;\n};\n\nvar read = (e, r, t, i) => {\n  var a = getMainOperation(r.query);\n  var n = e.rootFields[a.operation];\n  var o = getSelectionSet(a);\n  var s = makeContext(e, normalizeVariables(a, r.variables), getFragments(r.query), n, n, !1, i);\n  if (true) {\n    pushDebugNode(n, a);\n  }\n  if (!t) {\n    t = makeData();\n  }\n  var v = n !== s.store.rootFields.query ? readRoot(s, n, o, t) : readSelection(s, n, o, t);\n  if (true) {\n    popDebugNode();\n  }\n  return {\n    dependencies: getCurrentDependencies(),\n    partial: s.partial || !v,\n    data: v || null\n  };\n};\n\nvar readRoot = (e, r, t, i) => {\n  if (\"string\" != typeof (e.store.rootNames[r] ? r : i.__typename)) {\n    return i;\n  }\n  var a = makeSelectionIterator(r, r, t, e);\n  var n;\n  var o = !1;\n  var s = makeData(i);\n  while (n = a()) {\n    var v = getFieldAlias(n);\n    var l = i[v];\n    e.__internal.path.push(v);\n    var u = void 0;\n    if (n.selectionSet && null !== l) {\n      u = readRootField(e, getSelectionSet(n), ensureData(l));\n    } else {\n      u = l;\n    }\n    o = o || u !== l;\n    if (void 0 !== u) {\n      s[v] = u;\n    }\n    e.__internal.path.pop();\n  }\n  return o ? s : i;\n};\n\nvar readRootField = (e, r, t) => {\n  if (Array.isArray(t)) {\n    var i = new Array(t.length);\n    var a = !1;\n    for (var n = 0, o = t.length; n < o; n++) {\n      e.__internal.path.push(n);\n      i[n] = readRootField(e, r, t[n]);\n      a = a || i[n] !== t[n];\n      e.__internal.path.pop();\n    }\n    return a ? i : t;\n  } else if (null === t) {\n    return null;\n  }\n  var s = e.store.keyOfEntity(t);\n  if (null !== s) {\n    return readSelection(e, s, r, t) || null;\n  } else {\n    return readRoot(e, t.__typename, r, t);\n  }\n};\n\nvar readFragment = (e, r, t, i, a) => {\n  var n = getFragments(r);\n  var o;\n  if (a) {\n    if (!(o = n[a])) {\n       true && warn(\"readFragment(...) was called with a fragment name that does not exist.\\nYou provided \" + a + \" but could only find \" + Object.keys(n).join(\", \") + \".\", 6);\n      return null;\n    }\n  } else {\n    if (!(o = n[Object.keys(n)[0]])) {\n       true && warn(\"readFragment(...) was called with an empty fragment.\\nYou have to call it with at least one fragment in your GraphQL document.\", 6);\n      return null;\n    }\n  }\n  var s = getFragmentTypeName(o);\n  if (\"string\" != typeof t && !t.__typename) {\n    t.__typename = s;\n  }\n  var v = e.keyOfEntity(t);\n  if (!v) {\n     true && warn(\"Can't generate a key for readFragment(...).\\nYou have to pass an `id` or `_id` field or create a custom `keys` config for `\" + s + \"`.\", 7);\n    return null;\n  }\n  if (true) {\n    pushDebugNode(s, o);\n  }\n  var l = makeContext(e, i || {}, n, s, v);\n  var u = readSelection(l, v, getSelectionSet(o), makeData()) || null;\n  if (true) {\n    popDebugNode();\n  }\n  return u;\n};\n\nvar readSelection = (e, r, t, i, a) => {\n  var {store: n} = e;\n  var o = r === n.rootFields.query;\n  var s = a && n.keyOfEntity(a) || r;\n  if (true) {\n    if (!o && e.store.rootNames[s]) {\n      warn(\"Invalid root traversal: A selection was being read on `\" + s + \"` which is an uncached root type.\\nThe `\" + e.store.rootFields.mutation + \"` and `\" + e.store.rootFields.subscription + \"` types are special Operation Root Types and cannot be read back from the cache.\", 25);\n    }\n  }\n  var v = !o ? readRecord(s, \"__typename\") || a && a.__typename : r;\n  if (\"string\" != typeof v) {\n    return;\n  } else if (a && v !== a.__typename) {\n     true && warn(\"Invalid resolver data: The resolver at `\" + s + \"` returned an invalid typename that could not be reconciled with the cache.\", 8);\n    return;\n  }\n  var l = makeSelectionIterator(v, s, t, e);\n  var u = !1;\n  var d = !1;\n  var p = v !== i.__typename;\n  var c;\n  var f = makeData(i);\n  while (void 0 !== (c = l())) {\n    var y = getName(c);\n    var h = getFieldArguments(c, e.variables);\n    var m = getFieldAlias(c);\n    var g = keyOfField(y, h);\n    var _ = joinKeys(s, g);\n    var N = readRecord(s, g);\n    var k = a ? a[y] : void 0;\n    var E = n.resolvers[v];\n    if ( true && n.schema && v) {\n      isFieldAvailableOnType(n.schema, v, y);\n    }\n    e.__internal.path.push(m);\n    var O = void 0;\n    if (\"__typename\" === y) {\n      O = v;\n    } else if (void 0 !== k && void 0 === c.selectionSet) {\n      O = k;\n    } else if (\"read\" === getCurrentOperation() && E && \"function\" == typeof E[y]) {\n      updateContext(e, f, v, s, _, y);\n      if (void 0 !== N) {\n        f[m] = N;\n      }\n      O = E[y](f, h || {}, n, e);\n      if (c.selectionSet) {\n        O = resolveResolverResult(e, v, y, _, getSelectionSet(c), void 0 !== f[m] ? f[m] : i[m], O, ownsData(i));\n      }\n      if (n.schema && null === O && !isFieldNullable(n.schema, v, y)) {\n        return;\n      }\n    } else if (!c.selectionSet) {\n      O = N;\n    } else if (void 0 !== k) {\n      O = resolveResolverResult(e, v, y, _, getSelectionSet(c), void 0 !== f[m] ? f[m] : i[m], k, ownsData(i));\n    } else {\n      var w = readLink(s, g);\n      if (void 0 !== w) {\n        O = resolveLink(e, w, v, y, getSelectionSet(c), void 0 !== f[m] ? f[m] : i[m], ownsData(i));\n      } else if (\"object\" == typeof N && null !== N) {\n        O = N;\n      }\n    }\n    if (void 0 === O && q.current) {\n      u = !0;\n    } else if (void 0 === O && (n.schema && isFieldNullable(n.schema, v, y) || getFieldError(e))) {\n      d = !0;\n      O = null;\n    } else if (void 0 === O) {\n      e.__internal.path.pop();\n      return;\n    } else {\n      u = u || \"__typename\" !== y;\n    }\n    e.__internal.path.pop();\n    p = p || O !== i[m];\n    if (void 0 !== O) {\n      f[m] = O;\n    }\n  }\n  e.partial = e.partial || d;\n  return o && d && !u ? void 0 : p ? f : i;\n};\n\nvar resolveResolverResult = (e, r, t, i, a, n, o, s) => {\n  if (Array.isArray(o)) {\n    var {store: v} = e;\n    var l = v.schema ? isListNullable(v.schema, r, t) : !1;\n    var u = new Array(o.length);\n    var d = !Array.isArray(n) || o.length !== n.length;\n    for (var p = 0, c = o.length; p < c; p++) {\n      e.__internal.path.push(p);\n      var f = resolveResolverResult(e, r, t, joinKeys(i, `${p}`), a, null != n ? n[p] : void 0, o[p], s);\n      e.__internal.path.pop();\n      if (void 0 === f && !l) {\n        return;\n      } else {\n        e.partial = e.partial || void 0 === f && l;\n        u[p] = null != f ? f : null;\n        d = d || u[p] !== n[p];\n      }\n    }\n    return d ? u : n;\n  } else if (null == o) {\n    return o;\n  } else if (s && null === n) {\n    return null;\n  } else if (isDataOrKey(o)) {\n    var y = n || makeData();\n    return \"string\" == typeof o ? readSelection(e, o, a, y) : readSelection(e, i, a, y, o);\n  } else {\n     true && warn(\"Invalid resolver value: The field at `\" + i + \"` is a scalar (number, boolean, etc), but the GraphQL query expects a selection set for this field.\", 9);\n    return;\n  }\n};\n\nvar resolveLink = (e, r, t, i, a, n, o) => {\n  if (Array.isArray(r)) {\n    var {store: s} = e;\n    var v = s.schema ? isListNullable(s.schema, t, i) : !1;\n    var l = new Array(r.length);\n    var u = !Array.isArray(n) || l.length !== n.length;\n    for (var d = 0, p = r.length; d < p; d++) {\n      e.__internal.path.push(d);\n      var c = resolveLink(e, r[d], t, i, a, null != n ? n[d] : void 0, o);\n      e.__internal.path.pop();\n      if (void 0 === c && !v) {\n        return;\n      } else {\n        e.partial = e.partial || void 0 === c && v;\n        l[d] = c || null;\n        u = u || l[d] !== n[d];\n      }\n    }\n    return u ? l : n;\n  } else if (null === r || null === n && o) {\n    return null;\n  }\n  return readSelection(e, r, a, n || makeData());\n};\n\nvar isDataOrKey = e => \"string\" == typeof e || \"object\" == typeof e && \"string\" == typeof e.__typename;\n\nvar addCacheOutcome = (e, r) => (0,_urql_core__WEBPACK_IMPORTED_MODULE_1__.makeOperation)(e.kind, e, {\n  ...e.context,\n  meta: {\n    ...e.context.meta,\n    cacheOutcome: r\n  }\n});\n\nvar toRequestPolicy = (e, r) => (0,_urql_core__WEBPACK_IMPORTED_MODULE_1__.makeOperation)(e.kind, e, {\n  ...e.context,\n  requestPolicy: r\n});\n\nvar cacheExchange = e => ({forward: r, client: d, dispatchDebug: p}) => {\n  var c = new Store(e);\n  if (e && e.storage) {\n    e.storage.readData().then((r => {\n      ((e, r, t) => {\n        initDataState(\"write\", e, null);\n        for (var i in t) {\n          var a = t[i];\n          if (void 0 !== a) {\n            var {entityKey: n, fieldKey: o} = deserializeKeyInfo(i);\n            if (\":\" === a[0]) {\n              if (void 0 === readLink(n, o)) {\n                writeLink(n, o, JSON.parse(a.slice(1)));\n              }\n            } else if (void 0 === readRecord(n, o)) {\n              writeRecord(n, o, JSON.parse(a));\n            }\n          }\n        }\n        clearDataState();\n        e.storage = r;\n      })(c.data, e.storage, r);\n    }));\n  }\n  var f = new Map;\n  var y = [];\n  var h = new Map;\n  var m = new Map;\n  var g = new Set;\n  var _ = new Set;\n  var N = new Map;\n  var k = new Set;\n  var E = new Set;\n  var isBlockedByOptimisticUpdate = e => {\n    for (var r of e.values()) {\n      if (g.has(r)) {\n        return !0;\n      }\n    }\n    return !1;\n  };\n  var collectPendingOperations = (e, r) => {\n    if (r) {\n      for (var t of r.values()) {\n        var i = N.get(t);\n        if (i) {\n          for (var a of i.values()) {\n            e.add(a);\n          }\n        }\n      }\n    }\n  };\n  var executePendingOperations = (e, r) => {\n    for (var t of r.values()) {\n      if (t !== e.key) {\n        var i = h.get(t);\n        if (i) {\n          if (\"query\" === e.kind) {\n            E.add(t);\n          }\n          h.delete(t);\n          var a = \"cache-first\";\n          if (_.has(t)) {\n            _.delete(t);\n            a = \"cache-and-network\";\n          }\n          d.reexecuteOperation(toRequestPolicy(i, a));\n        }\n      }\n    }\n    var n = k;\n    if (\"query\" === e.kind) {\n      (k = E).add(e.key);\n    }\n    (E = n).clear();\n  };\n  var prepareForwardedOperation = e => {\n    if (\"query\" === e.kind) {\n      reserveLayer(c.data, e.key);\n    } else if (\"teardown\" === e.kind) {\n      h.delete(e.key);\n      m.delete(e.key);\n      noopDataState(c.data, e.key);\n    } else if (\"mutation\" === e.kind && \"network-only\" !== e.context.requestPolicy) {\n      var {dependencies: r} = ((e, r, t) => {\n        if (true) {\n          invariant(\"mutation\" === getMainOperation(r.query).operation,  true ? \"writeOptimistic(...) was called with an operation that is not a mutation.\\nThis case is unsupported and should never occur.\" : 0, 10);\n        }\n        initDataState(\"write\", e.data, t, !0);\n        var i = startWrite(e, r, {}, void 0, !0);\n        clearDataState();\n        return i;\n      })(c, e, e.key);\n      if (r.size) {\n        for (var a of r.values()) {\n          g.add(a);\n        }\n        f.set(e.key, r);\n        var n = new Set;\n        collectPendingOperations(n, r);\n        executePendingOperations(e, n);\n      }\n    }\n    return (0,_urql_core__WEBPACK_IMPORTED_MODULE_1__.makeOperation)(e.kind, {\n      key: e.key,\n      query: (0,_urql_core__WEBPACK_IMPORTED_MODULE_1__.formatDocument)(e.query),\n      variables: e.variables ? filterVariables(getMainOperation(e.query), e.variables) : e.variables\n    }, e.context);\n  };\n  var updateDependencies = (e, r) => {\n    for (var t of r.values()) {\n      var i = N.get(t);\n      if (!i) {\n        N.set(t, i = new Set);\n      }\n      i.add(e.key);\n    }\n  };\n  var operationResultFromCache = e => {\n    var r = query(c, e, m.get(e.key));\n    var t = r.data ? !r.partial ? \"hit\" : \"partial\" : \"miss\";\n    m.set(e.key, r.data);\n    h.set(e.key, e);\n    updateDependencies(e, r.dependencies);\n    return {\n      outcome: t,\n      operation: e,\n      data: r.data,\n      dependencies: r.dependencies\n    };\n  };\n  var updateCacheWithResult = (e, r) => {\n    var {error: t, extensions: a} = e;\n    var n = h.get(e.operation.key);\n    var o = n ? (0,_urql_core__WEBPACK_IMPORTED_MODULE_1__.makeOperation)(n.kind, n, e.operation.context) : e.operation;\n    if (\"mutation\" === o.kind) {\n      var s = f.get(o.key);\n      collectPendingOperations(r, s);\n      f.delete(o.key);\n    }\n    reserveLayer(c.data, o.key, \"subscription\" === o.kind || e.hasNext);\n    var v;\n    var l = e.data;\n    if (l) {\n      var u = write(c, o, l, e.error, o.key).dependencies;\n      collectPendingOperations(r, u);\n      var d = query(c, o, \"query\" === o.kind ? m.get(o.key) || l : l, e.error, o.key);\n      l = d.data;\n      if (\"query\" === o.kind) {\n        collectPendingOperations(r, v = d.dependencies);\n        m.set(o.key, l);\n      }\n    } else {\n      noopDataState(c.data, o.key);\n    }\n    if (v) {\n      h.set(o.key, o);\n      updateDependencies(e.operation, v);\n    }\n    return {\n      data: l,\n      error: t,\n      extensions: a,\n      operation: o\n    };\n  };\n  return e => {\n    var t = (0,wonka__WEBPACK_IMPORTED_MODULE_2__.share)(e);\n    var i = (0,wonka__WEBPACK_IMPORTED_MODULE_2__.share)((0,wonka__WEBPACK_IMPORTED_MODULE_2__.map)(operationResultFromCache)((0,wonka__WEBPACK_IMPORTED_MODULE_2__.filter)((e => \"query\" === e.kind && \"network-only\" !== e.context.requestPolicy))(t)));\n    var h = (0,wonka__WEBPACK_IMPORTED_MODULE_2__.filter)((e => \"query\" !== e.kind || \"network-only\" === e.context.requestPolicy))(t);\n    var m = (0,wonka__WEBPACK_IMPORTED_MODULE_2__.map)((e => {\n       true && p({\n        type: \"cacheMiss\",\n        message: \"The result could not be retrieved from the cache\",\n        operation: e.operation,\n        source: \"cacheExchange\"\n      });\n      return addCacheOutcome(e.operation, \"miss\");\n    }))((0,wonka__WEBPACK_IMPORTED_MODULE_2__.filter)((e => \"miss\" === e.outcome && \"cache-only\" !== e.operation.context.requestPolicy && !isBlockedByOptimisticUpdate(e.dependencies) && !k.has(e.operation.key)))(i));\n    var N = (0,wonka__WEBPACK_IMPORTED_MODULE_2__.map)((e => {\n      var {operation: r, outcome: t, dependencies: i} = e;\n      var a = {\n        operation: addCacheOutcome(r, t),\n        data: e.data,\n        error: e.error,\n        extensions: e.extensions\n      };\n      if (\"cache-and-network\" === r.context.requestPolicy || \"cache-first\" === r.context.requestPolicy && \"partial\" === t) {\n        a.stale = !0;\n        if (!isBlockedByOptimisticUpdate(i)) {\n          d.reexecuteOperation(toRequestPolicy(r, \"network-only\"));\n        } else if (\"cache-and-network\" === r.context.requestPolicy) {\n          _.add(r.key);\n        }\n      }\n       true && p({\n        type: \"cacheHit\",\n        message: \"A requested operation was found and returned from the cache.\",\n        operation: e.operation,\n        data: {\n          value: a\n        },\n        source: \"cacheExchange\"\n      });\n      return a;\n    }))((0,wonka__WEBPACK_IMPORTED_MODULE_2__.filter)((e => \"miss\" !== e.outcome || \"cache-only\" === e.operation.context.requestPolicy))(i));\n    var E = (0,wonka__WEBPACK_IMPORTED_MODULE_2__.share)(r((0,wonka__WEBPACK_IMPORTED_MODULE_2__.map)(prepareForwardedOperation)((0,wonka__WEBPACK_IMPORTED_MODULE_2__.merge)([ h, m ]))));\n    var O = (0,wonka__WEBPACK_IMPORTED_MODULE_2__.map)((e => {\n      var r = new Set;\n      var t = updateCacheWithResult(e, r);\n      executePendingOperations(e.operation, r);\n      return t;\n    }))((0,wonka__WEBPACK_IMPORTED_MODULE_2__.filter)((e => !f.has(e.operation.key)))(E));\n    var w = (0,wonka__WEBPACK_IMPORTED_MODULE_2__.mergeMap)((e => {\n      if (y.push(e) < f.size) {\n        return wonka__WEBPACK_IMPORTED_MODULE_2__.empty;\n      }\n      for (var r = 0; r < y.length; r++) {\n        reserveLayer(c.data, y[r].operation.key);\n      }\n      g.clear();\n      var t = [];\n      var i = new Set;\n      var a;\n      while (a = y.shift()) {\n        t.push(updateCacheWithResult(a, i));\n      }\n      executePendingOperations(e.operation, i);\n      return (0,wonka__WEBPACK_IMPORTED_MODULE_2__.fromArray)(t);\n    }))((0,wonka__WEBPACK_IMPORTED_MODULE_2__.filter)((e => f.has(e.operation.key)))(E));\n    return (0,wonka__WEBPACK_IMPORTED_MODULE_2__.merge)([ O, w, N ]);\n  };\n};\n\nvar isOfflineError = e => e && e.networkError && !e.response && (\"undefined\" != typeof navigator && !1 === navigator.onLine || /request failed|failed to fetch|network\\s?error/i.test(e.networkError.message));\n\nvar offlineExchange = e => t => {\n  var {storage: n} = e;\n  if (n && n.onOnline && n.readMetadata && n.writeMetadata) {\n    var {forward: v, client: l, dispatchDebug: u} = t;\n    var {source: p, next: c} = (0,wonka__WEBPACK_IMPORTED_MODULE_2__.makeSubject)();\n    var y = e.optimistic || {};\n    var h = [];\n    var updateMetadata = () => {\n      var e = [];\n      for (var r = 0; r < h.length; r++) {\n        var t = h[r];\n        if (\"mutation\" === t.kind) {\n          e.push({\n            query: (0,graphql__WEBPACK_IMPORTED_MODULE_0__.print)(t.query),\n            variables: t.variables\n          });\n        }\n      }\n      n.writeMetadata(e);\n    };\n    var m = !1;\n    var flushQueue = () => {\n      if (!m) {\n        m = !0;\n        for (var e = 0; e < h.length; e++) {\n          var r = h[e];\n          if (\"mutation\" === r.kind) {\n            c((0,_urql_core__WEBPACK_IMPORTED_MODULE_1__.makeOperation)(\"teardown\", r));\n          }\n        }\n        for (var t = 0; t < h.length; t++) {\n          l.reexecuteOperation(h[t]);\n        }\n        h.length = 0;\n        m = !1;\n        updateMetadata();\n      }\n    };\n    n.onOnline(flushQueue);\n    n.readMetadata().then((e => {\n      if (e) {\n        for (var t = 0; t < e.length; t++) {\n          h.push(l.createRequestOperation(\"mutation\", (0,_urql_core__WEBPACK_IMPORTED_MODULE_1__.createRequest)(e[t].query, e[t].variables)));\n        }\n        flushQueue();\n      }\n    }));\n    var g = cacheExchange({\n      ...e,\n      storage: {\n        ...n,\n        readData: () => n.readData().finally(flushQueue)\n      }\n    })({\n      client: l,\n      dispatchDebug: u,\n      forward: e => (0,wonka__WEBPACK_IMPORTED_MODULE_2__.filter)((e => {\n        if (\"mutation\" === e.operation.kind && isOfflineError(e.error) && ((e, r) => {\n          var t = r.variables || {};\n          var i = getFragments(r.query);\n          var a = [ ...getSelectionSet(getMainOperation(r.query)) ];\n          var n;\n          while (n = a.pop()) {\n            if (!shouldInclude(n, t)) {\n              continue;\n            } else if (!isFieldNode(n)) {\n              var o = !isInlineFragment(n) ? i[getName(n)] : n;\n              if (o) {\n                a.push(...getSelectionSet(o));\n              }\n            } else if (e[getName(n)]) {\n              return !0;\n            }\n          }\n          return !1;\n        })(y, e.operation)) {\n          h.push(e.operation);\n          updateMetadata();\n          return !1;\n        }\n        return !0;\n      }))(v(e))\n    });\n    return e => {\n      var r = (0,wonka__WEBPACK_IMPORTED_MODULE_2__.share)(e);\n      var t = (0,wonka__WEBPACK_IMPORTED_MODULE_2__.merge)([ p, r ]);\n      return (0,wonka__WEBPACK_IMPORTED_MODULE_2__.filter)((e => {\n        if (\"query\" === e.operation.kind && isOfflineError(e.error)) {\n          c(toRequestPolicy(e.operation, \"cache-only\"));\n          h.push(e.operation);\n          return !1;\n        }\n        return !0;\n      }))(g(t));\n    };\n  }\n  return cacheExchange(e)(t);\n};\n\n\n//# sourceMappingURL=urql-exchange-graphcache.mjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQHVycWwvZXhjaGFuZ2UtZ3JhcGhjYWNoZS9kaXN0L3VycWwtZXhjaGFuZ2UtZ3JhcGhjYWNoZS5tanMuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7QUFBa0g7O0FBRWlCOztBQUV6RDs7QUFFMUU7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsa0NBQWtDLCtDQUFPOztBQUV6Qyx1Q0FBdUMseURBQWlCOztBQUV4RDtBQUNBO0FBQ0E7QUFDQSw0Q0FBNEMsT0FBTztBQUNuRDtBQUNBLGNBQWMsNERBQUM7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0RBQW9ELE9BQU87QUFDM0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzREFBc0QsT0FBTztBQUM3RDtBQUNBO0FBQ0EsaURBQWlELDREQUFDO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsaUJBQWlCLHlEQUFpQjtBQUNsQyxtQ0FBbUMsRUFBRTtBQUNyQyxJQUFJLG9CQUFvQiw4REFBc0I7QUFDOUMsV0FBVyxhQUFhLGFBQWEsZ0JBQWdCLEVBQUUsWUFBWTtBQUNuRSxJQUFJLG9CQUFvQiw2REFBcUI7QUFDN0MsWUFBWSxhQUFhO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsUUFBUSxJQUFxQztBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxrQkFBa0IsMEJBQTBCO0FBQzVDLGtDQUFrQyw4REFBc0I7QUFDeEQ7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLEtB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O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLGdEQUFDO0FBQ2QsS0FBSyxHQUFHLDZDQUFDO0FBQ1QsV0FBVyw0Q0FBQztBQUNaO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSxPQUFPLFlBQVk7QUFDbkI7QUFDQSxTQUFTLHlDQUF5QztBQUNsRCxTQUFTLG9CQUFvQixFQUFFLGtEQUFDO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLGNBQWM7QUFDcEM7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLDhDQUFDO0FBQ3BCO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsY0FBYztBQUN0QztBQUNBO0FBQ0EsY0FBYyx5REFBQztBQUNmO0FBQ0E7QUFDQSx3QkFBd0IsY0FBYztBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixjQUFjO0FBQ3RDLHNEQUFzRCx5REFBQztBQUN2RDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxvQkFBb0IsNkNBQUM7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLEtBQUs7QUFDTDtBQUNBLGNBQWMsNENBQUM7QUFDZixjQUFjLDRDQUFDO0FBQ2YsYUFBYSw2Q0FBQztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTs7QUFFK0Q7QUFDL0QiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL0B1cnFsL2V4Y2hhbmdlLWdyYXBoY2FjaGUvZGlzdC91cnFsLWV4Y2hhbmdlLWdyYXBoY2FjaGUubWpzP2JmMWYiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgc3RyaW5naWZ5VmFyaWFibGVzIGFzIGUsIGNyZWF0ZVJlcXVlc3QgYXMgciwgZm9ybWF0RG9jdW1lbnQgYXMgdCwgbWFrZU9wZXJhdGlvbiBhcyBpIH0gZnJvbSBcIkB1cnFsL2NvcmVcIjtcblxuaW1wb3J0IHsgc2hhcmUgYXMgYSwgbWFwIGFzIG4sIGZpbHRlciBhcyBvLCBtZXJnZSBhcyBzLCBtZXJnZU1hcCBhcyB2LCBlbXB0eSBhcyBsLCBmcm9tQXJyYXkgYXMgdSwgbWFrZVN1YmplY3QgYXMgZCB9IGZyb20gXCJ3b25rYVwiO1xuXG5pbXBvcnQgeyBLaW5kIGFzIHAsIHZhbHVlRnJvbUFTVFVudHlwZWQgYXMgYywgcHJpbnQgYXMgZiB9IGZyb20gXCJncmFwaHFsXCI7XG5cbnZhciBnZXROYW1lID0gZSA9PiBlLm5hbWUudmFsdWU7XG5cbnZhciBnZXRGcmFnbWVudFR5cGVOYW1lID0gZSA9PiBlLnR5cGVDb25kaXRpb24ubmFtZS52YWx1ZTtcblxudmFyIGdldEZpZWxkQWxpYXMgPSBlID0+IGUuYWxpYXMgPyBlLmFsaWFzLnZhbHVlIDogZS5uYW1lLnZhbHVlO1xuXG52YXIgeSA9IFtdO1xuXG52YXIgZ2V0U2VsZWN0aW9uU2V0ID0gZSA9PiBlLnNlbGVjdGlvblNldCA/IGUuc2VsZWN0aW9uU2V0LnNlbGVjdGlvbnMgOiB5O1xuXG52YXIgZ2V0VHlwZUNvbmRpdGlvbiA9IGUgPT4gZS50eXBlQ29uZGl0aW9uID8gZS50eXBlQ29uZGl0aW9uLm5hbWUudmFsdWUgOiBudWxsO1xuXG52YXIgaXNGaWVsZE5vZGUgPSBlID0+IGUua2luZCA9PT0gcC5GSUVMRDtcblxudmFyIGlzSW5saW5lRnJhZ21lbnQgPSBlID0+IGUua2luZCA9PT0gcC5JTkxJTkVfRlJBR01FTlQ7XG5cbnZhciBnZXRGaWVsZEFyZ3VtZW50cyA9IChlLCByKSA9PiB7XG4gIHZhciB0ID0gbnVsbDtcbiAgaWYgKGUuYXJndW1lbnRzKSB7XG4gICAgZm9yICh2YXIgaSA9IDAsIGEgPSBlLmFyZ3VtZW50cy5sZW5ndGg7IGkgPCBhOyBpKyspIHtcbiAgICAgIHZhciBuID0gZS5hcmd1bWVudHNbaV07XG4gICAgICB2YXIgbyA9IGMobi52YWx1ZSwgcik7XG4gICAgICBpZiAobnVsbCAhPSBvKSB7XG4gICAgICAgIGlmICghdCkge1xuICAgICAgICAgIHQgPSB7fTtcbiAgICAgICAgfVxuICAgICAgICB0W2dldE5hbWUobildID0gbztcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIHQ7XG59O1xuXG52YXIgZmlsdGVyVmFyaWFibGVzID0gKGUsIHIpID0+IHtcbiAgaWYgKCFyIHx8ICFlLnZhcmlhYmxlRGVmaW5pdGlvbnMpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgdmFyIHQgPSB7fTtcbiAgZm9yICh2YXIgaSA9IDAsIGEgPSBlLnZhcmlhYmxlRGVmaW5pdGlvbnMubGVuZ3RoOyBpIDwgYTsgaSsrKSB7XG4gICAgdmFyIG4gPSBnZXROYW1lKGUudmFyaWFibGVEZWZpbml0aW9uc1tpXS52YXJpYWJsZSk7XG4gICAgdFtuXSA9IHJbbl07XG4gIH1cbiAgcmV0dXJuIHQ7XG59O1xuXG52YXIgbm9ybWFsaXplVmFyaWFibGVzID0gKGUsIHIpID0+IHtcbiAgdmFyIHQgPSB7fTtcbiAgaWYgKCFyKSB7XG4gICAgcmV0dXJuIHQ7XG4gIH1cbiAgaWYgKGUudmFyaWFibGVEZWZpbml0aW9ucykge1xuICAgIGZvciAodmFyIGkgPSAwLCBhID0gZS52YXJpYWJsZURlZmluaXRpb25zLmxlbmd0aDsgaSA8IGE7IGkrKykge1xuICAgICAgdmFyIG4gPSBlLnZhcmlhYmxlRGVmaW5pdGlvbnNbaV07XG4gICAgICB2YXIgbyA9IGdldE5hbWUobi52YXJpYWJsZSk7XG4gICAgICB0W29dID0gdm9pZCAwID09PSByW29dICYmIG4uZGVmYXVsdFZhbHVlID8gYyhuLmRlZmF1bHRWYWx1ZSwgcikgOiByW29dO1xuICAgIH1cbiAgfVxuICBmb3IgKHZhciBzIGluIHIpIHtcbiAgICBpZiAoIShzIGluIHQpKSB7XG4gICAgICB0W3NdID0gcltzXTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHQ7XG59O1xuXG52YXIgaCA9IFwiXFxuaHR0cHM6Ly9iaXQubHkvMlhiVnJwUiNcIjtcblxudmFyIG0gPSBuZXcgU2V0O1xuXG52YXIgZyA9IFtdO1xuXG52YXIgcG9wRGVidWdOb2RlID0gKCkgPT4gZy5wb3AoKTtcblxudmFyIHB1c2hEZWJ1Z05vZGUgPSAoZSwgcikgPT4ge1xuICB2YXIgdCA9IFwiXCI7XG4gIGlmIChyLmtpbmQgPT09IHAuSU5MSU5FX0ZSQUdNRU5UKSB7XG4gICAgdCA9IGUgPyBgSW5saW5lIEZyYWdtZW50IG9uIFwiJHtlfVwiYCA6IFwiSW5saW5lIEZyYWdtZW50XCI7XG4gIH0gZWxzZSBpZiAoci5raW5kID09PSBwLk9QRVJBVElPTl9ERUZJTklUSU9OKSB7XG4gICAgdCA9IGAke3IubmFtZSA/IGBcIiR7ci5uYW1lLnZhbHVlfVwiYCA6IFwiVW5uYW1lZFwifSAke3Iub3BlcmF0aW9ufWA7XG4gIH0gZWxzZSBpZiAoci5raW5kID09PSBwLkZSQUdNRU5UX0RFRklOSVRJT04pIHtcbiAgICB0ID0gYFwiJHtyLm5hbWUudmFsdWV9XCIgRnJhZ21lbnRgO1xuICB9XG4gIGlmICh0KSB7XG4gICAgZy5wdXNoKHQpO1xuICB9XG59O1xuXG52YXIgZ2V0RGVidWdPdXRwdXQgPSAoKSA9PiBnLmxlbmd0aCA/IFwiXFxuKENhdXNlZCBBdDogXCIgKyBnLmpvaW4oXCIsIFwiKSArIFwiKVwiIDogXCJcIjtcblxuZnVuY3Rpb24gaW52YXJpYW50KGUsIHIsIHQpIHtcbiAgaWYgKCFlKSB7XG4gICAgdmFyIGkgPSByIHx8IFwiTWluZmllZCBFcnJvciAjXCIgKyB0ICsgXCJcXG5cIjtcbiAgICBpZiAoXCJwcm9kdWN0aW9uXCIgIT09IHByb2Nlc3MuZW52Lk5PREVfRU5WKSB7XG4gICAgICBpICs9IGdldERlYnVnT3V0cHV0KCk7XG4gICAgfVxuICAgIHZhciBhID0gbmV3IEVycm9yKGkgKyBoICsgdCk7XG4gICAgYS5uYW1lID0gXCJHcmFwaGNhY2hlIEVycm9yXCI7XG4gICAgdGhyb3cgYTtcbiAgfVxufVxuXG5mdW5jdGlvbiB3YXJuKGUsIHIpIHtcbiAgaWYgKCFtLmhhcyhlKSkge1xuICAgIGNvbnNvbGUud2FybihlICsgZ2V0RGVidWdPdXRwdXQoKSArIGggKyByKTtcbiAgICBtLmFkZChlKTtcbiAgfVxufVxuXG52YXIgZ2V0TWFpbk9wZXJhdGlvbiA9IGUgPT4ge1xuICBmb3IgKHZhciByID0gMDsgciA8IGUuZGVmaW5pdGlvbnMubGVuZ3RoOyByKyspIHtcbiAgICBpZiAoZS5kZWZpbml0aW9uc1tyXS5raW5kID09PSBwLk9QRVJBVElPTl9ERUZJTklUSU9OKSB7XG4gICAgICByZXR1cm4gZS5kZWZpbml0aW9uc1tyXTtcbiAgICB9XG4gIH1cbiAgaW52YXJpYW50KCExLCBcInByb2R1Y3Rpb25cIiAhPT0gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgPyBcIkludmFsaWQgR3JhcGhRTCBkb2N1bWVudDogQWxsIEdyYXBoUUwgZG9jdW1lbnRzIG11c3QgY29udGFpbiBhbiBPcGVyYXRpb25EZWZpbml0aW9ubm9kZSBmb3IgYSBxdWVyeSwgc3Vic2NyaXB0aW9uLCBvciBtdXRhdGlvbi5cIiA6IFwiXCIsIDEpO1xufTtcblxudmFyIGdldEZyYWdtZW50cyA9IGUgPT4ge1xuICB2YXIgciA9IHt9O1xuICBmb3IgKHZhciB0ID0gMDsgdCA8IGUuZGVmaW5pdGlvbnMubGVuZ3RoOyB0KyspIHtcbiAgICB2YXIgaSA9IGUuZGVmaW5pdGlvbnNbdF07XG4gICAgaWYgKGkua2luZCA9PT0gcC5GUkFHTUVOVF9ERUZJTklUSU9OKSB7XG4gICAgICByW2dldE5hbWUoaSldID0gaTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHI7XG59O1xuXG52YXIgc2hvdWxkSW5jbHVkZSA9IChlLCByKSA9PiB7XG4gIGZvciAodmFyIHQgPSAwOyBlLmRpcmVjdGl2ZXMgJiYgdCA8IGUuZGlyZWN0aXZlcy5sZW5ndGg7IHQrKykge1xuICAgIHZhciBpID0gZS5kaXJlY3RpdmVzW3RdO1xuICAgIHZhciBhID0gZ2V0TmFtZShpKTtcbiAgICBpZiAoKFwiaW5jbHVkZVwiID09PSBhIHx8IFwic2tpcFwiID09PSBhKSAmJiBpLmFyZ3VtZW50cyAmJiBpLmFyZ3VtZW50c1swXSAmJiBcImlmXCIgPT09IGdldE5hbWUoaS5hcmd1bWVudHNbMF0pKSB7XG4gICAgICB2YXIgbiA9IGMoaS5hcmd1bWVudHNbMF0udmFsdWUsIHIpO1xuICAgICAgcmV0dXJuIFwiaW5jbHVkZVwiID09PSBhID8gISFuIDogIW47XG4gICAgfVxuICB9XG4gIHJldHVybiAhMDtcbn07XG5cbnZhciBpc0RlZmVycmVkID0gKGUsIHIpID0+IHtcbiAgZm9yICh2YXIgdCA9IDA7IGUuZGlyZWN0aXZlcyAmJiB0IDwgZS5kaXJlY3RpdmVzLmxlbmd0aDsgdCsrKSB7XG4gICAgdmFyIGkgPSBlLmRpcmVjdGl2ZXNbdF07XG4gICAgaWYgKFwiZGVmZXJcIiA9PT0gZ2V0TmFtZShpKSkge1xuICAgICAgZm9yICh2YXIgYSA9IDA7IGkuYXJndW1lbnRzICYmIGEgPCBpLmFyZ3VtZW50cy5sZW5ndGg7IGErKykge1xuICAgICAgICB2YXIgbiA9IGkuYXJndW1lbnRzW3RdO1xuICAgICAgICBpZiAoXCJpZlwiID09PSBnZXROYW1lKG4pKSB7XG4gICAgICAgICAgcmV0dXJuICEhYyhuLnZhbHVlLCByKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuICEwO1xuICAgIH1cbiAgfVxuICByZXR1cm4gITE7XG59O1xuXG52YXIgaXNGaWVsZE51bGxhYmxlID0gKGUsIHIsIHQpID0+IHtcbiAgdmFyIGkgPSBnZXRGaWVsZChlLCByLCB0KTtcbiAgcmV0dXJuICEhaSAmJiBcIk5PTl9OVUxMXCIgIT09IGkudHlwZS5raW5kO1xufTtcblxudmFyIGlzTGlzdE51bGxhYmxlID0gKGUsIHIsIHQpID0+IHtcbiAgdmFyIGkgPSBnZXRGaWVsZChlLCByLCB0KTtcbiAgaWYgKCFpKSB7XG4gICAgcmV0dXJuICExO1xuICB9XG4gIHZhciBhID0gXCJOT05fTlVMTFwiID09PSBpLnR5cGUua2luZCA/IGkudHlwZS5vZlR5cGUgOiBpLnR5cGU7XG4gIHJldHVybiBcIkxJU1RcIiA9PT0gYS5raW5kICYmIFwiTk9OX05VTExcIiAhPT0gYS5vZlR5cGUua2luZDtcbn07XG5cbnZhciBpc0ZpZWxkQXZhaWxhYmxlT25UeXBlID0gKGUsIHIsIHQpID0+IDAgPT09IHQuaW5kZXhPZihcIl9fXCIpIHx8IDAgPT09IHIuaW5kZXhPZihcIl9fXCIpIHx8ICEhZ2V0RmllbGQoZSwgciwgdCk7XG5cbnZhciBpc0ludGVyZmFjZU9mVHlwZSA9IChlLCByLCB0KSA9PiB7XG4gIGlmICghdCkge1xuICAgIHJldHVybiAhMTtcbiAgfVxuICB2YXIgaSA9IGdldFR5cGVDb25kaXRpb24ocik7XG4gIGlmICghaSB8fCB0ID09PSBpKSB7XG4gICAgcmV0dXJuICEwO1xuICB9IGVsc2UgaWYgKGUudHlwZXMuaGFzKGkpICYmIFwiT0JKRUNUXCIgPT09IGUudHlwZXMuZ2V0KGkpLmtpbmQpIHtcbiAgICByZXR1cm4gaSA9PT0gdDtcbiAgfVxuICAhZnVuY3Rpb24gZXhwZWN0QWJzdHJhY3RUeXBlKGUsIHIpIHtcbiAgICBpbnZhcmlhbnQoZS50eXBlcy5oYXMocikgJiYgKFwiSU5URVJGQUNFXCIgPT09IGUudHlwZXMuZ2V0KHIpLmtpbmQgfHwgXCJVTklPTlwiID09PSBlLnR5cGVzLmdldChyKS5raW5kKSwgXCJwcm9kdWN0aW9uXCIgIT09IHByb2Nlc3MuZW52Lk5PREVfRU5WID8gXCJJbnZhbGlkIEFic3RyYWN0IHR5cGU6IFRoZSB0eXBlIGBcIiArIHIgKyBcImAgaXMgbm90IGFuIEludGVyZmFjZSBvciBVbmlvbiB0eXBlIGluIHRoZSBkZWZpbmVkIHNjaGVtYSwgYnV0IGEgZnJhZ21lbnQgaW4gdGhlIEdyYXBoUUwgZG9jdW1lbnQgaXMgdXNpbmcgaXQgYXMgYSB0eXBlIGNvbmRpdGlvbi5cIiA6IFwiXCIsIDUpO1xuICB9KGUsIGkpO1xuICBleHBlY3RPYmplY3RUeXBlKGUsIHQpO1xuICByZXR1cm4gZS5pc1N1YlR5cGUoaSwgdCk7XG59O1xuXG52YXIgZ2V0RmllbGQgPSAoZSwgciwgdCkgPT4ge1xuICBpZiAoMCA9PT0gdC5pbmRleE9mKFwiX19cIikgfHwgMCA9PT0gci5pbmRleE9mKFwiX19cIikpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgZXhwZWN0T2JqZWN0VHlwZShlLCByKTtcbiAgdmFyIGkgPSBlLnR5cGVzLmdldChyKS5maWVsZHMoKVt0XTtcbiAgaWYgKFwicHJvZHVjdGlvblwiICE9PSBwcm9jZXNzLmVudi5OT0RFX0VOVikge1xuICAgIGlmICghaSkge1xuICAgICAgd2FybihcIkludmFsaWQgZmllbGQ6IFRoZSBmaWVsZCBgXCIgKyB0ICsgXCJgIGRvZXMgbm90IGV4aXN0IG9uIGBcIiArIHIgKyBcImAsIGJ1dCB0aGUgR3JhcGhRTCBkb2N1bWVudCBleHBlY3RzIGl0IHRvIGV4aXN0LlxcblRyYXZlcnNhbCB3aWxsIGNvbnRpbnVlLCBob3dldmVyIHRoaXMgbWF5IGxlYWQgdG8gdW5kZWZpbmVkIGJlaGF2aW9yIVwiLCA0KTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGk7XG59O1xuXG5mdW5jdGlvbiBleHBlY3RPYmplY3RUeXBlKGUsIHIpIHtcbiAgaW52YXJpYW50KGUudHlwZXMuaGFzKHIpICYmIFwiT0JKRUNUXCIgPT09IGUudHlwZXMuZ2V0KHIpLmtpbmQsIFwicHJvZHVjdGlvblwiICE9PSBwcm9jZXNzLmVudi5OT0RFX0VOViA/IFwiSW52YWxpZCBPYmplY3QgdHlwZTogVGhlIHR5cGUgYFwiICsgciArIFwiYCBpcyBub3QgYW4gb2JqZWN0IGluIHRoZSBkZWZpbmVkIHNjaGVtYSwgYnV0IHRoZSBHcmFwaFFMIGRvY3VtZW50IGlzIHRyYXZlcnNpbmcgaXQuXCIgOiBcIlwiLCAzKTtcbn1cblxuZnVuY3Rpb24gd2FybkFib3V0UmVzb2x2ZXIoZSkge1xuICBcInByb2R1Y3Rpb25cIiAhPT0gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgJiYgd2FybihgSW52YWxpZCByZXNvbHZlcjogXFxgJHtlfVxcYCBpcyBub3QgaW4gdGhlIGRlZmluZWQgc2NoZW1hLCBidXQgdGhlIFxcYHJlc29sdmVyc1xcYCBvcHRpb24gaXMgcmVmZXJlbmNpbmcgaXQuYCwgMjMpO1xufVxuXG52YXIga2V5T2ZGaWVsZCA9IChyLCB0KSA9PiB0ID8gYCR7cn0oJHtlKHQpfSlgIDogcjtcblxudmFyIGpvaW5LZXlzID0gKGUsIHIpID0+IGAke2V9LiR7cn1gO1xuXG52YXIgZmllbGRJbmZvT2ZLZXkgPSBlID0+IHtcbiAgdmFyIHIgPSBlLmluZGV4T2YoXCIoXCIpO1xuICBpZiAociA+IC0xKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGZpZWxkS2V5OiBlLFxuICAgICAgZmllbGROYW1lOiBlLnNsaWNlKDAsIHIpLFxuICAgICAgYXJndW1lbnRzOiBKU09OLnBhcnNlKGUuc2xpY2UociArIDEsIC0xKSlcbiAgICB9O1xuICB9IGVsc2Uge1xuICAgIHJldHVybiB7XG4gICAgICBmaWVsZEtleTogZSxcbiAgICAgIGZpZWxkTmFtZTogZSxcbiAgICAgIGFyZ3VtZW50czogbnVsbFxuICAgIH07XG4gIH1cbn07XG5cbnZhciBkZXNlcmlhbGl6ZUtleUluZm8gPSBlID0+IHtcbiAgdmFyIHIgPSBlLmluZGV4T2YoXCIuXCIpO1xuICByZXR1cm4ge1xuICAgIGVudGl0eUtleTogZS5zbGljZSgwLCByKS5yZXBsYWNlKC8lMmUvZywgXCIuXCIpLFxuICAgIGZpZWxkS2V5OiBlLnNsaWNlKHIgKyAxKVxuICB9O1xufTtcblxudmFyIG1ha2VEaWN0ID0gKCkgPT4gT2JqZWN0LmNyZWF0ZShudWxsKTtcblxudmFyIF8gPSBudWxsO1xuXG52YXIgTiA9IG51bGw7XG5cbnZhciBrID0gbnVsbDtcblxudmFyIEUgPSBudWxsO1xuXG52YXIgTyA9IG51bGw7XG5cbnZhciB3ID0gbnVsbDtcblxudmFyIGIgPSAhMTtcblxudmFyIG1ha2VEYXRhID0gZSA9PiB7XG4gIHZhciByO1xuICBpZiAoZSkge1xuICAgIGlmIChfLmhhcyhlKSkge1xuICAgICAgcmV0dXJuIGU7XG4gICAgfVxuICAgIHIgPSBOLmdldChlKSB8fCB7XG4gICAgICAuLi5lXG4gICAgfTtcbiAgICBOLnNldChlLCByKTtcbiAgfSBlbHNlIHtcbiAgICByID0ge307XG4gIH1cbiAgXy5hZGQocik7XG4gIHJldHVybiByO1xufTtcblxudmFyIG93bnNEYXRhID0gZSA9PiAhIWUgJiYgXy5oYXMoZSk7XG5cbnZhciBpbml0RGF0YVN0YXRlID0gKGUsIHIsIHQsIGkpID0+IHtcbiAgXyA9IG5ldyBXZWFrU2V0O1xuICBOID0gbmV3IFdlYWtNYXA7XG4gIGsgPSBlO1xuICBFID0gcjtcbiAgTyA9IG5ldyBTZXQ7XG4gIGIgPSAhIWk7XG4gIGlmIChcInByb2R1Y3Rpb25cIiAhPT0gcHJvY2Vzcy5lbnYuTk9ERV9FTlYpIHtcbiAgICBnLmxlbmd0aCA9IDA7XG4gIH1cbiAgaWYgKCF0KSB7XG4gICAgdyA9IG51bGw7XG4gIH0gZWxzZSBpZiAoXCJyZWFkXCIgPT09IGspIHtcbiAgICB3ID0gdDtcbiAgfSBlbHNlIGlmIChpIHx8IHIub3B0aW1pc3RpY09yZGVyLmxlbmd0aCA+IDEpIHtcbiAgICBpZiAoIWkgJiYgIXIuY29tbXV0YXRpdmVLZXlzLmhhcyh0KSkge1xuICAgICAgcmVzZXJ2ZUxheWVyKHIsIHQpO1xuICAgIH0gZWxzZSBpZiAoaSkge1xuICAgICAgaWYgKC0xICE9PSByLm9wdGltaXN0aWNPcmRlci5pbmRleE9mKHQpICYmICFyLmNvbW11dGF0aXZlS2V5cy5oYXModCkpIHtcbiAgICAgICAgci5vcHRpbWlzdGljT3JkZXIuc3BsaWNlKHIub3B0aW1pc3RpY09yZGVyLmluZGV4T2YodCksIDEpO1xuICAgICAgfVxuICAgICAgci5jb21tdXRhdGl2ZUtleXMuZGVsZXRlKHQpO1xuICAgIH1cbiAgICB3ID0gdDtcbiAgICBjcmVhdGVMYXllcihyLCB0KTtcbiAgfSBlbHNlIHtcbiAgICB3ID0gbnVsbDtcbiAgICBkZWxldGVMYXllcihyLCB0KTtcbiAgfVxufTtcblxudmFyIGNsZWFyRGF0YVN0YXRlID0gKCkgPT4ge1xuICBpZiAoXCJwcm9kdWN0aW9uXCIgIT09IHByb2Nlc3MuZW52Lk5PREVfRU5WKSB7XG4gICAgZ2V0Q3VycmVudERlcGVuZGVuY2llcygpO1xuICB9XG4gIHZhciBlID0gRTtcbiAgdmFyIHIgPSB3O1xuICBiID0gITE7XG4gIHcgPSBudWxsO1xuICBpZiAociAmJiBlLm9wdGltaXN0aWNPcmRlci5pbmRleE9mKHIpID4gLTEpIHtcbiAgICB2YXIgdCA9IGUub3B0aW1pc3RpY09yZGVyLmxlbmd0aDtcbiAgICB3aGlsZSAoLS10ID49IDAgJiYgZS5yZWZMb2NrLmhhcyhlLm9wdGltaXN0aWNPcmRlclt0XSkgJiYgZS5jb21tdXRhdGl2ZUtleXMuaGFzKGUub3B0aW1pc3RpY09yZGVyW3RdKSAmJiAhZS5kZWZlcnJlZEtleXMuaGFzKGUub3B0aW1pc3RpY09yZGVyW3RdKSkge1xuICAgICAgc3F1YXNoTGF5ZXIoZS5vcHRpbWlzdGljT3JkZXJbdF0pO1xuICAgIH1cbiAgfVxuICBfID0gbnVsbDtcbiAgTiA9IG51bGw7XG4gIGsgPSBudWxsO1xuICBFID0gbnVsbDtcbiAgTyA9IG51bGw7XG4gIGlmIChcInByb2R1Y3Rpb25cIiAhPT0gcHJvY2Vzcy5lbnYuTk9ERV9FTlYpIHtcbiAgICBnLmxlbmd0aCA9IDA7XG4gIH1cbiAgaWYgKFwidGVzdFwiICE9PSBwcm9jZXNzLmVudi5OT0RFX0VOViAmJiAhZS5kZWZlcikge1xuICAgIGUuZGVmZXIgPSAhMDtcbiAgICBzZXRUaW1lb3V0KCgoKSA9PiB7XG4gICAgICBpbml0RGF0YVN0YXRlKFwicmVhZFwiLCBlLCBudWxsKTtcbiAgICAgIGdjKCk7XG4gICAgICBwZXJzaXN0RGF0YSgpO1xuICAgICAgY2xlYXJEYXRhU3RhdGUoKTtcbiAgICAgIGUuZGVmZXIgPSAhMTtcbiAgICB9KSk7XG4gIH1cbn07XG5cbnZhciBub29wRGF0YVN0YXRlID0gKGUsIHIsIHQpID0+IHtcbiAgaWYgKHIgJiYgIXQpIHtcbiAgICBlLmRlZmVycmVkS2V5cy5kZWxldGUocik7XG4gIH1cbiAgaW5pdERhdGFTdGF0ZShcIndyaXRlXCIsIGUsIHIsIHQpO1xuICBjbGVhckRhdGFTdGF0ZSgpO1xufTtcblxudmFyIGdldEN1cnJlbnRPcGVyYXRpb24gPSAoKSA9PiB7XG4gIGludmFyaWFudChudWxsICE9PSBrLCBcInByb2R1Y3Rpb25cIiAhPT0gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgPyBcIkludmFsaWQgQ2FjaGUgY2FsbDogVGhlIGNhY2hlIG1heSBvbmx5IGJlIGFjY2Vzc2VkIG9yIG11dGF0ZWQgZHVyaW5nb3BlcmF0aW9ucyBsaWtlIHdyaXRlIG9yIHF1ZXJ5LCBvciBhcyBwYXJ0IG9mIGl0cyByZXNvbHZlcnMsIHVwZGF0ZXJzLCBvciBvcHRpbWlzdGljIGNvbmZpZ3MuXCIgOiBcIlwiLCAyKTtcbiAgcmV0dXJuIGs7XG59O1xuXG52YXIgZ2V0Q3VycmVudERlcGVuZGVuY2llcyA9ICgpID0+IHtcbiAgaW52YXJpYW50KG51bGwgIT09IE8sIFwicHJvZHVjdGlvblwiICE9PSBwcm9jZXNzLmVudi5OT0RFX0VOViA/IFwiSW52YWxpZCBDYWNoZSBjYWxsOiBUaGUgY2FjaGUgbWF5IG9ubHkgYmUgYWNjZXNzZWQgb3IgbXV0YXRlZCBkdXJpbmdvcGVyYXRpb25zIGxpa2Ugd3JpdGUgb3IgcXVlcnksIG9yIGFzIHBhcnQgb2YgaXRzIHJlc29sdmVycywgdXBkYXRlcnMsIG9yIG9wdGltaXN0aWMgY29uZmlncy5cIiA6IFwiXCIsIDIpO1xuICByZXR1cm4gTztcbn07XG5cbnZhciBzZXROb2RlID0gKGUsIHIsIHQsIGkpID0+IHtcbiAgdmFyIGEgPSB3ID8gZS5vcHRpbWlzdGljLmdldCh3KSA6IGUuYmFzZTtcbiAgdmFyIG4gPSBhLmdldChyKTtcbiAgaWYgKHZvaWQgMCA9PT0gbikge1xuICAgIGEuc2V0KHIsIG4gPSBtYWtlRGljdCgpKTtcbiAgfVxuICBpZiAodm9pZCAwID09PSBpICYmICF3KSB7XG4gICAgZGVsZXRlIG5bdF07XG4gIH0gZWxzZSB7XG4gICAgblt0XSA9IGk7XG4gIH1cbn07XG5cbnZhciBnZXROb2RlID0gKGUsIHIsIHQpID0+IHtcbiAgdmFyIGk7XG4gIHZhciBhID0gIWIgJiYgXCJyZWFkXCIgPT09IGsgJiYgdyAmJiBFLmNvbW11dGF0aXZlS2V5cy5oYXModyk7XG4gIGZvciAodmFyIG4gPSAwLCBvID0gRS5vcHRpbWlzdGljT3JkZXIubGVuZ3RoOyBuIDwgbzsgbisrKSB7XG4gICAgdmFyIHMgPSBFLm9wdGltaXN0aWNPcmRlcltuXTtcbiAgICB2YXIgdiA9IGUub3B0aW1pc3RpYy5nZXQocyk7XG4gICAgYSA9IGEgJiYgcyAhPT0gdztcbiAgICBpZiAodiAmJiAoIWEgfHwgIUUuY29tbXV0YXRpdmVLZXlzLmhhcyhzKSkgJiYgKCFiIHx8IFwid3JpdGVcIiA9PT0gayB8fCBFLmNvbW11dGF0aXZlS2V5cy5oYXMocykpICYmIHZvaWQgMCAhPT0gKGkgPSB2LmdldChyKSkgJiYgdCBpbiBpKSB7XG4gICAgICByZXR1cm4gaVt0XTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHZvaWQgMCAhPT0gKGkgPSBlLmJhc2UuZ2V0KHIpKSA/IGlbdF0gOiB2b2lkIDA7XG59O1xuXG52YXIgdXBkYXRlUkNGb3JFbnRpdHkgPSAoZSwgciwgdCwgaSkgPT4ge1xuICB2YXIgYSA9IHIuZ2V0KHQpIHx8IDA7XG4gIHZhciBuID0gYSArIGk7XG4gIHIuc2V0KHQsIG4pO1xuICBpZiAoZSkge1xuICAgIGlmIChuIDw9IDApIHtcbiAgICAgIGUuYWRkKHQpO1xuICAgIH0gZWxzZSBpZiAoYSA8PSAwICYmIG4gPiAwKSB7XG4gICAgICBlLmRlbGV0ZSh0KTtcbiAgICB9XG4gIH1cbn07XG5cbnZhciB1cGRhdGVSQ0ZvckxpbmsgPSAoZSwgciwgdCwgaSkgPT4ge1xuICBpZiAoXCJzdHJpbmdcIiA9PSB0eXBlb2YgdCkge1xuICAgIHVwZGF0ZVJDRm9yRW50aXR5KGUsIHIsIHQsIGkpO1xuICB9IGVsc2UgaWYgKEFycmF5LmlzQXJyYXkodCkpIHtcbiAgICBmb3IgKHZhciBhID0gMCwgbiA9IHQubGVuZ3RoOyBhIDwgbjsgYSsrKSB7XG4gICAgICBpZiAoQXJyYXkuaXNBcnJheSh0W2FdKSkge1xuICAgICAgICB1cGRhdGVSQ0ZvckxpbmsoZSwgciwgdFthXSwgaSk7XG4gICAgICB9IGVsc2UgaWYgKHRbYV0pIHtcbiAgICAgICAgdXBkYXRlUkNGb3JFbnRpdHkoZSwgciwgdFthXSwgaSk7XG4gICAgICB9XG4gICAgfVxuICB9XG59O1xuXG52YXIgZXh0cmFjdE5vZGVGaWVsZHMgPSAoZSwgciwgdCkgPT4ge1xuICBpZiAodm9pZCAwICE9PSB0KSB7XG4gICAgZm9yICh2YXIgaSBpbiB0KSB7XG4gICAgICBpZiAoIXIuaGFzKGkpKSB7XG4gICAgICAgIGUucHVzaChmaWVsZEluZm9PZktleShpKSk7XG4gICAgICAgIHIuYWRkKGkpO1xuICAgICAgfVxuICAgIH1cbiAgfVxufTtcblxudmFyIGV4dHJhY3ROb2RlTWFwRmllbGRzID0gKGUsIHIsIHQsIGkpID0+IHtcbiAgZXh0cmFjdE5vZGVGaWVsZHMoZSwgciwgaS5iYXNlLmdldCh0KSk7XG4gIGZvciAodmFyIGEgPSAwLCBuID0gRS5vcHRpbWlzdGljT3JkZXIubGVuZ3RoOyBhIDwgbjsgYSsrKSB7XG4gICAgdmFyIG8gPSBpLm9wdGltaXN0aWMuZ2V0KEUub3B0aW1pc3RpY09yZGVyW2FdKTtcbiAgICBpZiAodm9pZCAwICE9PSBvKSB7XG4gICAgICBleHRyYWN0Tm9kZUZpZWxkcyhlLCByLCBvLmdldCh0KSk7XG4gICAgfVxuICB9XG59O1xuXG52YXIgZ2MgPSAoKSA9PiB7XG4gIHZhciB7Z2M6IGV9ID0gRTtcbiAgZm9yICh2YXIgciBvZiBlLmtleXMoKSkge1xuICAgIGlmICgoRS5yZWZDb3VudC5nZXQocikgfHwgMCkgPiAwKSB7XG4gICAgICBlLmRlbGV0ZShyKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgZm9yICh2YXIgdCBvZiBFLnJlZkxvY2sua2V5cygpKSB7XG4gICAgICB2YXIgaSA9IEUucmVmTG9jay5nZXQodCk7XG4gICAgICBpZiAoaSkge1xuICAgICAgICBpZiAoKGkuZ2V0KHIpIHx8IDApID4gMCkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpLmRlbGV0ZShyKTtcbiAgICAgIH1cbiAgICB9XG4gICAgRS5yZWZDb3VudC5kZWxldGUocik7XG4gICAgZS5kZWxldGUocik7XG4gICAgRS5yZWNvcmRzLmJhc2UuZGVsZXRlKHIpO1xuICAgIHZhciBhID0gRS5saW5rcy5iYXNlLmdldChyKTtcbiAgICBpZiAoYSkge1xuICAgICAgRS5saW5rcy5iYXNlLmRlbGV0ZShyKTtcbiAgICAgIGZvciAodmFyIG4gaW4gYSkge1xuICAgICAgICB1cGRhdGVSQ0ZvckxpbmsoZSwgRS5yZWZDb3VudCwgYVtuXSwgLTEpO1xuICAgICAgfVxuICAgIH1cbiAgfVxufTtcblxudmFyIHVwZGF0ZURlcGVuZGVuY2llcyA9IChlLCByKSA9PiB7XG4gIGlmIChcIl9fdHlwZW5hbWVcIiAhPT0gcikge1xuICAgIGlmIChlICE9PSBFLnF1ZXJ5Um9vdEtleSkge1xuICAgICAgTy5hZGQoZSk7XG4gICAgfSBlbHNlIGlmICh2b2lkIDAgIT09IHIpIHtcbiAgICAgIE8uYWRkKGpvaW5LZXlzKGUsIHIpKTtcbiAgICB9XG4gIH1cbn07XG5cbnZhciB1cGRhdGVQZXJzaXN0ID0gKGUsIHIpID0+IHtcbiAgaWYgKCFiICYmIEUuc3RvcmFnZSkge1xuICAgIEUucGVyc2lzdC5hZGQoKChlLCByKSA9PiBgJHtlLnJlcGxhY2UoL1xcLi9nLCBcIiUyZVwiKX0uJHtyfWApKGUsIHIpKTtcbiAgfVxufTtcblxudmFyIHJlYWRSZWNvcmQgPSAoZSwgcikgPT4ge1xuICB1cGRhdGVEZXBlbmRlbmNpZXMoZSwgcik7XG4gIHJldHVybiBnZXROb2RlKEUucmVjb3JkcywgZSwgcik7XG59O1xuXG52YXIgcmVhZExpbmsgPSAoZSwgcikgPT4ge1xuICB1cGRhdGVEZXBlbmRlbmNpZXMoZSwgcik7XG4gIHJldHVybiBnZXROb2RlKEUubGlua3MsIGUsIHIpO1xufTtcblxudmFyIHdyaXRlUmVjb3JkID0gKGUsIHIsIHQpID0+IHtcbiAgdXBkYXRlRGVwZW5kZW5jaWVzKGUsIHIpO1xuICB1cGRhdGVQZXJzaXN0KGUsIHIpO1xuICBzZXROb2RlKEUucmVjb3JkcywgZSwgciwgdCk7XG59O1xuXG52YXIgd3JpdGVMaW5rID0gKGUsIHIsIHQpID0+IHtcbiAgdmFyIGkgPSBFO1xuICB2YXIgYTtcbiAgdmFyIG47XG4gIHZhciBvO1xuICBpZiAodykge1xuICAgIGlmICghKGEgPSBpLnJlZkxvY2suZ2V0KHcpKSkge1xuICAgICAgaS5yZWZMb2NrLnNldCh3LCBhID0gbmV3IE1hcCk7XG4gICAgfVxuICAgIG4gPSBpLmxpbmtzLm9wdGltaXN0aWMuZ2V0KHcpO1xuICB9IGVsc2Uge1xuICAgIGEgPSBpLnJlZkNvdW50O1xuICAgIG4gPSBpLmxpbmtzLmJhc2U7XG4gICAgbyA9IGkuZ2M7XG4gIH1cbiAgdmFyIHMgPSBuICYmIG4uZ2V0KGUpO1xuICB2YXIgdiA9IHMgJiYgc1tyXTtcbiAgdXBkYXRlRGVwZW5kZW5jaWVzKGUsIHIpO1xuICB1cGRhdGVQZXJzaXN0KGUsIHIpO1xuICBzZXROb2RlKGkubGlua3MsIGUsIHIsIHQpO1xuICB1cGRhdGVSQ0ZvckxpbmsobywgYSwgdiwgLTEpO1xuICB1cGRhdGVSQ0ZvckxpbmsobywgYSwgdCwgMSk7XG59O1xuXG52YXIgcmVzZXJ2ZUxheWVyID0gKGUsIHIsIHQpID0+IHtcbiAgaWYgKHQpIHtcbiAgICBlLmRlZmVycmVkS2V5cy5hZGQocik7XG4gIH0gZWxzZSB7XG4gICAgZS5kZWZlcnJlZEtleXMuZGVsZXRlKHIpO1xuICB9XG4gIHZhciBpID0gZS5vcHRpbWlzdGljT3JkZXIuaW5kZXhPZihyKTtcbiAgaWYgKGkgPiAtMSkge1xuICAgIGlmICghZS5jb21tdXRhdGl2ZUtleXMuaGFzKHIpICYmICF0KSB7XG4gICAgICBlLm9wdGltaXN0aWNPcmRlci5zcGxpY2UoaSwgMSk7XG4gICAgICBjbGVhckxheWVyKGUsIHIpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICB9XG4gIGZvciAoaSA9IDA7IHQgJiYgaSA8IGUub3B0aW1pc3RpY09yZGVyLmxlbmd0aCAmJiAhZS5kZWZlcnJlZEtleXMuaGFzKGUub3B0aW1pc3RpY09yZGVyW2ldKSAmJiAoIWUucmVmTG9jay5oYXMoZS5vcHRpbWlzdGljT3JkZXJbaV0pIHx8ICFlLmNvbW11dGF0aXZlS2V5cy5oYXMoZS5vcHRpbWlzdGljT3JkZXJbaV0pKTsgaSsrKSB7fVxuICBlLm9wdGltaXN0aWNPcmRlci5zcGxpY2UoaSwgMCwgcik7XG4gIGUuY29tbXV0YXRpdmVLZXlzLmFkZChyKTtcbn07XG5cbnZhciBjcmVhdGVMYXllciA9IChlLCByKSA9PiB7XG4gIGlmICgtMSA9PT0gZS5vcHRpbWlzdGljT3JkZXIuaW5kZXhPZihyKSkge1xuICAgIGUub3B0aW1pc3RpY09yZGVyLnVuc2hpZnQocik7XG4gIH1cbiAgaWYgKCFlLnJlZkxvY2suaGFzKHIpKSB7XG4gICAgZS5yZWZMb2NrLnNldChyLCBuZXcgTWFwKTtcbiAgICBlLmxpbmtzLm9wdGltaXN0aWMuc2V0KHIsIG5ldyBNYXApO1xuICAgIGUucmVjb3Jkcy5vcHRpbWlzdGljLnNldChyLCBuZXcgTWFwKTtcbiAgfVxufTtcblxudmFyIGNsZWFyTGF5ZXIgPSAoZSwgcikgPT4ge1xuICBpZiAoZS5yZWZMb2NrLmhhcyhyKSkge1xuICAgIGUucmVmTG9jay5kZWxldGUocik7XG4gICAgZS5yZWNvcmRzLm9wdGltaXN0aWMuZGVsZXRlKHIpO1xuICAgIGUubGlua3Mub3B0aW1pc3RpYy5kZWxldGUocik7XG4gICAgZS5kZWZlcnJlZEtleXMuZGVsZXRlKHIpO1xuICB9XG59O1xuXG52YXIgZGVsZXRlTGF5ZXIgPSAoZSwgcikgPT4ge1xuICB2YXIgdCA9IGUub3B0aW1pc3RpY09yZGVyLmluZGV4T2Yocik7XG4gIGlmICh0ID4gLTEpIHtcbiAgICBlLm9wdGltaXN0aWNPcmRlci5zcGxpY2UodCwgMSk7XG4gICAgZS5jb21tdXRhdGl2ZUtleXMuZGVsZXRlKHIpO1xuICB9XG4gIGNsZWFyTGF5ZXIoZSwgcik7XG59O1xuXG52YXIgc3F1YXNoTGF5ZXIgPSBlID0+IHtcbiAgdmFyIHIgPSBPO1xuICBPID0gbmV3IFNldDtcbiAgdmFyIHQgPSBFLmxpbmtzLm9wdGltaXN0aWMuZ2V0KGUpO1xuICBpZiAodCkge1xuICAgIGZvciAodmFyIGkgb2YgdC5lbnRyaWVzKCkpIHtcbiAgICAgIHZhciBhID0gaVswXTtcbiAgICAgIHZhciBuID0gaVsxXTtcbiAgICAgIGZvciAodmFyIG8gaW4gbikge1xuICAgICAgICB3cml0ZUxpbmsoYSwgbywgbltvXSk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHZhciBzID0gRS5yZWNvcmRzLm9wdGltaXN0aWMuZ2V0KGUpO1xuICBpZiAocykge1xuICAgIGZvciAodmFyIHYgb2Ygcy5lbnRyaWVzKCkpIHtcbiAgICAgIHZhciBsID0gdlswXTtcbiAgICAgIHZhciB1ID0gdlsxXTtcbiAgICAgIGZvciAodmFyIGQgaW4gdSkge1xuICAgICAgICB3cml0ZVJlY29yZChsLCBkLCB1W2RdKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgTyA9IHI7XG4gIGRlbGV0ZUxheWVyKEUsIGUpO1xufTtcblxudmFyIGluc3BlY3RGaWVsZHMgPSBlID0+IHtcbiAgdmFyIHtsaW5rczogciwgcmVjb3JkczogdH0gPSBFO1xuICB2YXIgaSA9IFtdO1xuICB2YXIgYSA9IG5ldyBTZXQ7XG4gIHVwZGF0ZURlcGVuZGVuY2llcyhlKTtcbiAgZXh0cmFjdE5vZGVNYXBGaWVsZHMoaSwgYSwgZSwgcik7XG4gIGV4dHJhY3ROb2RlTWFwRmllbGRzKGksIGEsIGUsIHQpO1xuICByZXR1cm4gaTtcbn07XG5cbnZhciBwZXJzaXN0RGF0YSA9ICgpID0+IHtcbiAgaWYgKEUuc3RvcmFnZSkge1xuICAgIGIgPSAhMDtcbiAgICBrID0gXCJyZWFkXCI7XG4gICAgdmFyIHIgPSBtYWtlRGljdCgpO1xuICAgIGZvciAodmFyIHQgb2YgRS5wZXJzaXN0LmtleXMoKSkge1xuICAgICAgdmFyIHtlbnRpdHlLZXk6IGksIGZpZWxkS2V5OiBhfSA9IGRlc2VyaWFsaXplS2V5SW5mbyh0KTtcbiAgICAgIHZhciBuID0gdm9pZCAwO1xuICAgICAgaWYgKHZvaWQgMCAhPT0gKG4gPSByZWFkTGluayhpLCBhKSkpIHtcbiAgICAgICAgclt0XSA9IGA6JHtlKG4pfWA7XG4gICAgICB9IGVsc2UgaWYgKHZvaWQgMCAhPT0gKG4gPSByZWFkUmVjb3JkKGksIGEpKSkge1xuICAgICAgICByW3RdID0gZShuKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJbdF0gPSB2b2lkIDA7XG4gICAgICB9XG4gICAgfVxuICAgIGIgPSAhMTtcbiAgICBFLnN0b3JhZ2Uud3JpdGVEYXRhKHIpO1xuICAgIEUucGVyc2lzdC5jbGVhcigpO1xuICB9XG59O1xuXG52YXIgRCA9IHtcbiAgY3VycmVudDogbnVsbFxufTtcblxudmFyIHEgPSB7XG4gIGN1cnJlbnQ6ICExXG59O1xuXG52YXIgZ2V0RmllbGRFcnJvciA9IGUgPT4gZS5fX2ludGVybmFsLnBhdGgubGVuZ3RoID4gMCAmJiBlLl9faW50ZXJuYWwuZXJyb3JNYXAgPyBlLl9faW50ZXJuYWwuZXJyb3JNYXBbZS5fX2ludGVybmFsLnBhdGguam9pbihcIi5cIildIDogdm9pZCAwO1xuXG52YXIgbWFrZUNvbnRleHQgPSAoZSwgciwgdCwgaSwgYSwgbiwgbykgPT4ge1xuICB2YXIgcyA9IHtcbiAgICBzdG9yZTogZSxcbiAgICB2YXJpYWJsZXM6IHIsXG4gICAgZnJhZ21lbnRzOiB0LFxuICAgIHBhcmVudDoge1xuICAgICAgX190eXBlbmFtZTogaVxuICAgIH0sXG4gICAgcGFyZW50VHlwZU5hbWU6IGksXG4gICAgcGFyZW50S2V5OiBhLFxuICAgIHBhcmVudEZpZWxkS2V5OiBcIlwiLFxuICAgIGZpZWxkTmFtZTogXCJcIixcbiAgICBlcnJvcjogdm9pZCAwLFxuICAgIHBhcnRpYWw6ICExLFxuICAgIG9wdGltaXN0aWM6ICEhbixcbiAgICBfX2ludGVybmFsOiB7XG4gICAgICBwYXRoOiBbXSxcbiAgICAgIGVycm9yTWFwOiB2b2lkIDBcbiAgICB9XG4gIH07XG4gIGlmIChvICYmIG8uZ3JhcGhRTEVycm9ycykge1xuICAgIGZvciAodmFyIHYgPSAwOyB2IDwgby5ncmFwaFFMRXJyb3JzLmxlbmd0aDsgdisrKSB7XG4gICAgICB2YXIgbCA9IG8uZ3JhcGhRTEVycm9yc1t2XTtcbiAgICAgIGlmIChsLnBhdGggJiYgbC5wYXRoLmxlbmd0aCkge1xuICAgICAgICBpZiAoIXMuX19pbnRlcm5hbC5lcnJvck1hcCkge1xuICAgICAgICAgIHMuX19pbnRlcm5hbC5lcnJvck1hcCA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgICAgIH1cbiAgICAgICAgcy5fX2ludGVybmFsLmVycm9yTWFwW2wucGF0aC5qb2luKFwiLlwiKV0gPSBsO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICByZXR1cm4gcztcbn07XG5cbnZhciB1cGRhdGVDb250ZXh0ID0gKGUsIHIsIHQsIGksIGEsIG4pID0+IHtcbiAgRC5jdXJyZW50ID0gZTtcbiAgZS5wYXJlbnQgPSByO1xuICBlLnBhcmVudFR5cGVOYW1lID0gdDtcbiAgZS5wYXJlbnRLZXkgPSBpO1xuICBlLnBhcmVudEZpZWxkS2V5ID0gYTtcbiAgZS5maWVsZE5hbWUgPSBuO1xuICBlLmVycm9yID0gZ2V0RmllbGRFcnJvcihlKTtcbn07XG5cbnZhciBpc0ZyYWdtZW50SGV1cmlzdGljYWxseU1hdGNoaW5nID0gKGUsIHIsIHQsIGkpID0+IHtcbiAgaWYgKCFyKSB7XG4gICAgcmV0dXJuICExO1xuICB9XG4gIHZhciBhID0gZ2V0VHlwZUNvbmRpdGlvbihlKTtcbiAgaWYgKCFhIHx8IHIgPT09IGEpIHtcbiAgICByZXR1cm4gITA7XG4gIH1cbiAgXCJwcm9kdWN0aW9uXCIgIT09IHByb2Nlc3MuZW52Lk5PREVfRU5WICYmIHdhcm4oXCJIZXVyaXN0aWMgRnJhZ21lbnQgTWF0Y2hpbmc6IEEgZnJhZ21lbnQgaXMgdHJ5aW5nIHRvIG1hdGNoIGFnYWluc3QgdGhlIGBcIiArIHIgKyBcImAgdHlwZSwgYnV0IHRoZSB0eXBlIGNvbmRpdGlvbiBpcyBgXCIgKyBhICsgXCJgLiBTaW5jZSBHcmFwaFFMIGFsbG93cyBmb3IgaW50ZXJmYWNlcyBgXCIgKyBhICsgXCJgIG1heSBiZSBhbmludGVyZmFjZS5cXG5BIHNjaGVtYSBuZWVkcyB0byBiZSBkZWZpbmVkIGZvciB0aGlzIG1hdGNoIHRvIGJlIGRldGVybWluaXN0aWMsIG90aGVyd2lzZSB0aGUgZnJhZ21lbnQgd2lsbCBiZSBtYXRjaGVkIGhldXJpc3RpY2FsbHkhXCIsIDE2KTtcbiAgcmV0dXJuIFwid3JpdGVcIiA9PT0gayB8fCAhZ2V0U2VsZWN0aW9uU2V0KGUpLnNvbWUoKGUgPT4ge1xuICAgIGlmICghaXNGaWVsZE5vZGUoZSkpIHtcbiAgICAgIHJldHVybiAhMTtcbiAgICB9XG4gICAgdmFyIHIgPSBrZXlPZkZpZWxkKGdldE5hbWUoZSksIGdldEZpZWxkQXJndW1lbnRzKGUsIGkpKTtcbiAgICByZXR1cm4gISgoZSwgcikgPT4gdm9pZCAwICE9PSByZWFkUmVjb3JkKGUsIHIpIHx8IHZvaWQgMCAhPT0gcmVhZExpbmsoZSwgcikpKHQsIHIpO1xuICB9KSk7XG59O1xuXG52YXIgbWFrZVNlbGVjdGlvbkl0ZXJhdG9yID0gKGUsIHIsIHQsIGkpID0+IHtcbiAgdmFyIGEgPSAhMTtcbiAgdmFyIG47XG4gIHZhciBvID0gMDtcbiAgcmV0dXJuIGZ1bmN0aW9uIG5leHQoKSB7XG4gICAgaWYgKCFxLmN1cnJlbnQgJiYgYSkge1xuICAgICAgcS5jdXJyZW50ID0gYTtcbiAgICB9XG4gICAgaWYgKG4pIHtcbiAgICAgIHZhciBzID0gbigpO1xuICAgICAgaWYgKG51bGwgIT0gcykge1xuICAgICAgICByZXR1cm4gcztcbiAgICAgIH1cbiAgICAgIG4gPSB2b2lkIDA7XG4gICAgICBhID0gITE7XG4gICAgICBpZiAoXCJwcm9kdWN0aW9uXCIgIT09IHByb2Nlc3MuZW52Lk5PREVfRU5WKSB7XG4gICAgICAgIHBvcERlYnVnTm9kZSgpO1xuICAgICAgfVxuICAgIH1cbiAgICB3aGlsZSAobyA8IHQubGVuZ3RoKSB7XG4gICAgICB2YXIgdiA9IHRbbysrXTtcbiAgICAgIGlmICghc2hvdWxkSW5jbHVkZSh2LCBpLnZhcmlhYmxlcykpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9IGVsc2UgaWYgKCFpc0ZpZWxkTm9kZSh2KSkge1xuICAgICAgICB2YXIgbCA9ICFpc0lubGluZUZyYWdtZW50KHYpID8gaS5mcmFnbWVudHNbZ2V0TmFtZSh2KV0gOiB2O1xuICAgICAgICBpZiAodm9pZCAwICE9PSBsKSB7XG4gICAgICAgICAgaWYgKGkuc3RvcmUuc2NoZW1hID8gaXNJbnRlcmZhY2VPZlR5cGUoaS5zdG9yZS5zY2hlbWEsIGwsIGUpIDogaXNGcmFnbWVudEhldXJpc3RpY2FsbHlNYXRjaGluZyhsLCBlLCByLCBpLnZhcmlhYmxlcykpIHtcbiAgICAgICAgICAgIGlmIChcInByb2R1Y3Rpb25cIiAhPT0gcHJvY2Vzcy5lbnYuTk9ERV9FTlYpIHtcbiAgICAgICAgICAgICAgcHVzaERlYnVnTm9kZShlLCBsKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGEgPSAhIWlzRGVmZXJyZWQodiwgaS52YXJpYWJsZXMpO1xuICAgICAgICAgICAgaWYgKCFxLmN1cnJlbnQgJiYgYSkge1xuICAgICAgICAgICAgICBxLmN1cnJlbnQgPSBhO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIChuID0gbWFrZVNlbGVjdGlvbkl0ZXJhdG9yKGUsIHIsIGdldFNlbGVjdGlvblNldChsKSwgaSkpKCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gdjtcbiAgICAgIH1cbiAgICB9XG4gIH07XG59O1xuXG52YXIgZW5zdXJlRGF0YSA9IGUgPT4gbnVsbCA9PSBlID8gbnVsbCA6IGU7XG5cbnZhciBlbnN1cmVMaW5rID0gKGUsIHIpID0+IHtcbiAgaWYgKG51bGwgPT0gcikge1xuICAgIHJldHVybiByO1xuICB9IGVsc2UgaWYgKEFycmF5LmlzQXJyYXkocikpIHtcbiAgICB2YXIgdCA9IG5ldyBBcnJheShyLmxlbmd0aCk7XG4gICAgZm9yICh2YXIgaSA9IDAsIGEgPSB0Lmxlbmd0aDsgaSA8IGE7IGkrKykge1xuICAgICAgdFtpXSA9IGVuc3VyZUxpbmsoZSwgcltpXSk7XG4gICAgfVxuICAgIHJldHVybiB0O1xuICB9XG4gIHZhciBuID0gZS5rZXlPZkVudGl0eShyKTtcbiAgaWYgKFwicHJvZHVjdGlvblwiICE9PSBwcm9jZXNzLmVudi5OT0RFX0VOVikge1xuICAgIGlmICghbiAmJiByICYmIFwib2JqZWN0XCIgPT0gdHlwZW9mIHIpIHtcbiAgICAgIHdhcm4oXCJDYW4ndCBnZW5lcmF0ZSBhIGtleSBmb3IgbGluayguLi4pIGl0ZW0uXFxuWW91IGhhdmUgdG8gcGFzcyBhbiBgaWRgIG9yIGBfaWRgIGZpZWxkIG9yIGNyZWF0ZSBhIGN1c3RvbSBga2V5c2AgY29uZmlnIGZvciBgXCIgKyByLl9fdHlwZW5hbWUgKyBcImAuXCIsIDEyKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIG47XG59O1xuXG52YXIgd3JpdGUgPSAoZSwgciwgdCwgaSwgYSkgPT4ge1xuICBpbml0RGF0YVN0YXRlKFwid3JpdGVcIiwgZS5kYXRhLCBhIHx8IG51bGwpO1xuICB2YXIgbiA9IHN0YXJ0V3JpdGUoZSwgciwgdCwgaSk7XG4gIGNsZWFyRGF0YVN0YXRlKCk7XG4gIHJldHVybiBuO1xufTtcblxudmFyIHN0YXJ0V3JpdGUgPSAoZSwgciwgdCwgaSwgYSkgPT4ge1xuICB2YXIgbiA9IGdldE1haW5PcGVyYXRpb24oci5xdWVyeSk7XG4gIHZhciBvID0ge1xuICAgIGRhdGE6IHQsXG4gICAgZGVwZW5kZW5jaWVzOiBnZXRDdXJyZW50RGVwZW5kZW5jaWVzKClcbiAgfTtcbiAgdmFyIHMgPSBlLnJvb3RGaWVsZHNbbi5vcGVyYXRpb25dO1xuICB2YXIgdiA9IG1ha2VDb250ZXh0KGUsIG5vcm1hbGl6ZVZhcmlhYmxlcyhuLCByLnZhcmlhYmxlcyksIGdldEZyYWdtZW50cyhyLnF1ZXJ5KSwgcywgcywgISFhLCBpKTtcbiAgaWYgKFwicHJvZHVjdGlvblwiICE9PSBwcm9jZXNzLmVudi5OT0RFX0VOVikge1xuICAgIHB1c2hEZWJ1Z05vZGUocywgbik7XG4gIH1cbiAgd3JpdGVTZWxlY3Rpb24odiwgcywgZ2V0U2VsZWN0aW9uU2V0KG4pLCB0KTtcbiAgaWYgKFwicHJvZHVjdGlvblwiICE9PSBwcm9jZXNzLmVudi5OT0RFX0VOVikge1xuICAgIHBvcERlYnVnTm9kZSgpO1xuICB9XG4gIHJldHVybiBvO1xufTtcblxudmFyIHdyaXRlU2VsZWN0aW9uID0gKGUsIHIsIHQsIGkpID0+IHtcbiAgdmFyIGEgPSByID09PSBlLnN0b3JlLnJvb3RGaWVsZHMucXVlcnk7XG4gIHZhciBuID0gIWEgJiYgISFlLnN0b3JlLnJvb3ROYW1lc1tyXTtcbiAgdmFyIG8gPSBuIHx8IGEgPyByIDogaS5fX3R5cGVuYW1lO1xuICBpZiAoIW8pIHtcbiAgICBcInByb2R1Y3Rpb25cIiAhPT0gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgJiYgd2FybihcIkNvdWxkbid0IGZpbmQgX190eXBlbmFtZSB3aGVuIHdyaXRpbmcuXFxuSWYgeW91J3JlIHdyaXRpbmcgdG8gdGhlIGNhY2hlIG1hbnVhbGx5IGhhdmUgdG8gcGFzcyBhIGBfX3R5cGVuYW1lYCBwcm9wZXJ0eSBvbiBlYWNoIGVudGl0eSBpbiB5b3VyIGRhdGEuXCIsIDE0KTtcbiAgICByZXR1cm47XG4gIH0gZWxzZSBpZiAoIW4gJiYgIWEgJiYgcikge1xuICAgIHdyaXRlUmVjb3JkKHIsIFwiX190eXBlbmFtZVwiLCBvKTtcbiAgfVxuICB2YXIgcyA9IG1ha2VTZWxlY3Rpb25JdGVyYXRvcihvLCByIHx8IG8sIHQsIGUpO1xuICB2YXIgdjtcbiAgd2hpbGUgKHYgPSBzKCkpIHtcbiAgICB2YXIgbCA9IGdldE5hbWUodik7XG4gICAgdmFyIHUgPSBnZXRGaWVsZEFyZ3VtZW50cyh2LCBlLnZhcmlhYmxlcyk7XG4gICAgdmFyIGQgPSBrZXlPZkZpZWxkKGwsIHUpO1xuICAgIHZhciBwID0gZ2V0RmllbGRBbGlhcyh2KTtcbiAgICB2YXIgYyA9IGlbZS5vcHRpbWlzdGljID8gbCA6IHBdO1xuICAgIGlmIChcInByb2R1Y3Rpb25cIiAhPT0gcHJvY2Vzcy5lbnYuTk9ERV9FTlYpIHtcbiAgICAgIGlmICghbiAmJiB2b2lkIDAgPT09IGMgJiYgIXEuY3VycmVudCAmJiAhZS5vcHRpbWlzdGljKSB7XG4gICAgICAgIFwicHJvZHVjdGlvblwiICE9PSBwcm9jZXNzLmVudi5OT0RFX0VOViAmJiB3YXJuKFwiSW52YWxpZCB1bmRlZmluZWQ6IFRoZSBmaWVsZCBhdCBgXCIgKyBkICsgXCJgIGlzIGB1bmRlZmluZWRgLCBidXQgdGhlIEdyYXBoUUwgcXVlcnkgZXhwZWN0cyBhIFwiICsgKHZvaWQgMCA9PT0gdi5zZWxlY3Rpb25TZXQgPyBcInNjYWxhciAobnVtYmVyLCBib29sZWFuLCBldGMpXCIgOiBcInNlbGVjdGlvbiBzZXRcIikgKyBcIiBmb3IgdGhpcyBmaWVsZC5cIiwgMTMpO1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH0gZWxzZSBpZiAoZS5zdG9yZS5zY2hlbWEgJiYgbyAmJiBcIl9fdHlwZW5hbWVcIiAhPT0gbCkge1xuICAgICAgICBpc0ZpZWxkQXZhaWxhYmxlT25UeXBlKGUuc3RvcmUuc2NoZW1hLCBvLCBsKTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKFwiX190eXBlbmFtZVwiID09PSBsIHx8IHZvaWQgMCA9PT0gYyAmJiAocS5jdXJyZW50IHx8IGUub3B0aW1pc3RpYyAmJiAhbikpIHtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cbiAgICBlLl9faW50ZXJuYWwucGF0aC5wdXNoKHApO1xuICAgIHZhciBmID0gdm9pZCAwO1xuICAgIGlmIChlLm9wdGltaXN0aWMgJiYgbikge1xuICAgICAgaWYgKCEoZiA9IGUuc3RvcmUub3B0aW1pc3RpY011dGF0aW9uc1tsXSkpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChlLm9wdGltaXN0aWMgJiYgXCJmdW5jdGlvblwiID09IHR5cGVvZiBjKSB7XG4gICAgICBmID0gYztcbiAgICB9XG4gICAgaWYgKGYpIHtcbiAgICAgIHVwZGF0ZUNvbnRleHQoZSwgaSwgbywgbywgZCwgbCk7XG4gICAgICBjID0gZW5zdXJlRGF0YShmKHUgfHwge30sIGUuc3RvcmUsIGUpKTtcbiAgICB9XG4gICAgaWYgKHYuc2VsZWN0aW9uU2V0KSB7XG4gICAgICBpZiAociAmJiAhbikge1xuICAgICAgICB2YXIgeSA9IGpvaW5LZXlzKHIsIGQpO1xuICAgICAgICB2YXIgaCA9IHdyaXRlRmllbGQoZSwgZ2V0U2VsZWN0aW9uU2V0KHYpLCBlbnN1cmVEYXRhKGMpLCB5KTtcbiAgICAgICAgd3JpdGVMaW5rKHIgfHwgbywgZCwgaCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB3cml0ZUZpZWxkKGUsIGdldFNlbGVjdGlvblNldCh2KSwgZW5zdXJlRGF0YShjKSk7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChyICYmICFuKSB7XG4gICAgICB3cml0ZVJlY29yZChyIHx8IG8sIGQsIG51bGwgIT09IGMgfHwgIWdldEZpZWxkRXJyb3IoZSkgPyBjIDogdm9pZCAwKTtcbiAgICB9XG4gICAgaWYgKG4pIHtcbiAgICAgIHZhciBtID0gZS5zdG9yZS51cGRhdGVzW29dW2xdO1xuICAgICAgaWYgKG0pIHtcbiAgICAgICAgdXBkYXRlQ29udGV4dChlLCBpLCBvLCBvLCBqb2luS2V5cyhvLCBkKSwgbCk7XG4gICAgICAgIGlbbF0gPSBjO1xuICAgICAgICBtKGksIHUgfHwge30sIGUuc3RvcmUsIGUpO1xuICAgICAgfVxuICAgIH1cbiAgICBlLl9faW50ZXJuYWwucGF0aC5wb3AoKTtcbiAgfVxufTtcblxudmFyIFYgPSAvXl9ffFBhZ2VJbmZvfChDb25uZWN0aW9ufEVkZ2UpJC87XG5cbnZhciB3cml0ZUZpZWxkID0gKGUsIHIsIHQsIGkpID0+IHtcbiAgaWYgKEFycmF5LmlzQXJyYXkodCkpIHtcbiAgICB2YXIgYSA9IG5ldyBBcnJheSh0Lmxlbmd0aCk7XG4gICAgZm9yICh2YXIgbiA9IDAsIG8gPSB0Lmxlbmd0aDsgbiA8IG87IG4rKykge1xuICAgICAgZS5fX2ludGVybmFsLnBhdGgucHVzaChuKTtcbiAgICAgIHZhciBzID0gaSA/IGpvaW5LZXlzKGksIGAke259YCkgOiB2b2lkIDA7XG4gICAgICB2YXIgdiA9IHdyaXRlRmllbGQoZSwgciwgdFtuXSwgcyk7XG4gICAgICBhW25dID0gdjtcbiAgICAgIGUuX19pbnRlcm5hbC5wYXRoLnBvcCgpO1xuICAgIH1cbiAgICByZXR1cm4gYTtcbiAgfSBlbHNlIGlmIChudWxsID09PSB0KSB7XG4gICAgcmV0dXJuIGdldEZpZWxkRXJyb3IoZSkgPyB2b2lkIDAgOiBudWxsO1xuICB9XG4gIHZhciBsID0gZS5zdG9yZS5rZXlPZkVudGl0eSh0KTtcbiAgdmFyIHUgPSB0Ll9fdHlwZW5hbWU7XG4gIGlmIChcInByb2R1Y3Rpb25cIiAhPT0gcHJvY2Vzcy5lbnYuTk9ERV9FTlYpIHtcbiAgICBpZiAoaSAmJiAhZS5zdG9yZS5rZXlzW3QuX190eXBlbmFtZV0gJiYgbnVsbCA9PT0gbCAmJiBcInN0cmluZ1wiID09IHR5cGVvZiB1ICYmICFWLnRlc3QodSkpIHtcbiAgICAgIHdhcm4oXCJJbnZhbGlkIGtleTogVGhlIEdyYXBoUUwgcXVlcnkgYXQgdGhlIGZpZWxkIGF0IGBcIiArIGkgKyBcImAgaGFzIGEgc2VsZWN0aW9uIHNldCwgYnV0IG5vIGtleSBjb3VsZCBiZSBnZW5lcmF0ZWQgZm9yIHRoZSBkYXRhIGF0IHRoaXMgZmllbGQuXFxuWW91IGhhdmUgdG8gcmVxdWVzdCBgaWRgIG9yIGBfaWRgIGZpZWxkcyBmb3IgYWxsIHNlbGVjdGlvbiBzZXRzIG9yIGNyZWF0ZSBhIGN1c3RvbSBga2V5c2AgY29uZmlnIGZvciBgXCIgKyB1ICsgXCJgLlxcbkVudGl0aWVzIHdpdGhvdXQga2V5cyB3aWxsIGJlIGVtYmVkZGVkIGRpcmVjdGx5IG9uIHRoZSBwYXJlbnQgZW50aXR5LiBJZiB0aGlzIGlzIGludGVudGlvbmFsLCBjcmVhdGUgYSBga2V5c2AgY29uZmlnIGZvciBgXCIgKyB1ICsgXCJgIHRoYXQgYWx3YXlzIHJldHVybnMgbnVsbC5cIiwgMTUpO1xuICAgIH1cbiAgfVxuICB2YXIgZCA9IGwgfHwgaTtcbiAgd3JpdGVTZWxlY3Rpb24oZSwgZCwgciwgdCk7XG4gIHJldHVybiBkIHx8IG51bGw7XG59O1xuXG5jbGFzcyBTdG9yZSB7XG4gIGNvbnN0cnVjdG9yKGUpIHtcbiAgICBTdG9yZS5wcm90b3R5cGUuX19pbml0LmNhbGwodGhpcyk7XG4gICAgU3RvcmUucHJvdG90eXBlLl9faW5pdDIuY2FsbCh0aGlzKTtcbiAgICBpZiAoIWUpIHtcbiAgICAgIGUgPSB7fTtcbiAgICB9XG4gICAgdGhpcy5yZXNvbHZlcnMgPSBlLnJlc29sdmVycyB8fCB7fTtcbiAgICB0aGlzLm9wdGltaXN0aWNNdXRhdGlvbnMgPSBlLm9wdGltaXN0aWMgfHwge307XG4gICAgdGhpcy5rZXlzID0gZS5rZXlzIHx8IHt9O1xuICAgIHZhciByID0gXCJRdWVyeVwiO1xuICAgIHZhciB0ID0gXCJNdXRhdGlvblwiO1xuICAgIHZhciBpID0gXCJTdWJzY3JpcHRpb25cIjtcbiAgICBpZiAoZS5zY2hlbWEpIHtcbiAgICAgIHZhciBhID0gKCh7X19zY2hlbWE6IGV9KSA9PiB7XG4gICAgICAgIHZhciByID0gbmV3IE1hcDtcbiAgICAgICAgdmFyIGJ1aWxkTmFtZU1hcCA9IGUgPT4ge1xuICAgICAgICAgIHZhciByO1xuICAgICAgICAgIHJldHVybiAoKSA9PiB7XG4gICAgICAgICAgICBpZiAoIXIpIHtcbiAgICAgICAgICAgICAgciA9IHt9O1xuICAgICAgICAgICAgICBmb3IgKHZhciB0ID0gMDsgdCA8IGUubGVuZ3RoOyB0KyspIHtcbiAgICAgICAgICAgICAgICByW2VbdF0ubmFtZV0gPSBlW3RdO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gcjtcbiAgICAgICAgICB9O1xuICAgICAgICB9O1xuICAgICAgICB2YXIgYnVpbGRUeXBlID0gZSA9PiB7XG4gICAgICAgICAgc3dpdGNoIChlLmtpbmQpIHtcbiAgICAgICAgICAgY2FzZSBcIk9CSkVDVFwiOlxuICAgICAgICAgICBjYXNlIFwiSU5URVJGQUNFXCI6XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICBuYW1lOiBlLm5hbWUsXG4gICAgICAgICAgICAgIGtpbmQ6IGUua2luZCxcbiAgICAgICAgICAgICAgaW50ZXJmYWNlczogYnVpbGROYW1lTWFwKGUuaW50ZXJmYWNlcyB8fCBbXSksXG4gICAgICAgICAgICAgIGZpZWxkczogYnVpbGROYW1lTWFwKGUuZmllbGRzLm1hcCgoZSA9PiAoe1xuICAgICAgICAgICAgICAgIG5hbWU6IGUubmFtZSxcbiAgICAgICAgICAgICAgICB0eXBlOiBlLnR5cGUsXG4gICAgICAgICAgICAgICAgYXJnczogYnVpbGROYW1lTWFwKGUuYXJncylcbiAgICAgICAgICAgICAgfSkpKSlcbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgY2FzZSBcIlVOSU9OXCI6XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICBuYW1lOiBlLm5hbWUsXG4gICAgICAgICAgICAgIGtpbmQ6IGUua2luZCxcbiAgICAgICAgICAgICAgdHlwZXM6IGJ1aWxkTmFtZU1hcChlLnBvc3NpYmxlVHlwZXMgfHwgW10pXG4gICAgICAgICAgICB9O1xuICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgdmFyIHQgPSB7XG4gICAgICAgICAgcXVlcnk6IGUucXVlcnlUeXBlID8gZS5xdWVyeVR5cGUubmFtZSA6IG51bGwsXG4gICAgICAgICAgbXV0YXRpb246IGUubXV0YXRpb25UeXBlID8gZS5tdXRhdGlvblR5cGUubmFtZSA6IG51bGwsXG4gICAgICAgICAgc3Vic2NyaXB0aW9uOiBlLnN1YnNjcmlwdGlvblR5cGUgPyBlLnN1YnNjcmlwdGlvblR5cGUubmFtZSA6IG51bGwsXG4gICAgICAgICAgdHlwZXM6IHZvaWQgMCxcbiAgICAgICAgICBpc1N1YlR5cGUoZSwgdCkge1xuICAgICAgICAgICAgdmFyIGkgPSByLmdldChlKTtcbiAgICAgICAgICAgIHZhciBhID0gci5nZXQodCk7XG4gICAgICAgICAgICBpZiAoIWkgfHwgIWEpIHtcbiAgICAgICAgICAgICAgcmV0dXJuICExO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChcIlVOSU9OXCIgPT09IGkua2luZCkge1xuICAgICAgICAgICAgICByZXR1cm4gISFpLnR5cGVzKClbdF07XG4gICAgICAgICAgICB9IGVsc2UgaWYgKFwiT0JKRUNUXCIgIT09IGkua2luZCAmJiBcIk9CSkVDVFwiID09PSBhLmtpbmQpIHtcbiAgICAgICAgICAgICAgcmV0dXJuICEhYS5pbnRlcmZhY2VzKClbZV07XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICByZXR1cm4gZSA9PT0gdDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIGlmIChlLnR5cGVzKSB7XG4gICAgICAgICAgdC50eXBlcyA9IHI7XG4gICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBlLnR5cGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICB2YXIgYSA9IGUudHlwZXNbaV07XG4gICAgICAgICAgICBpZiAoYSAmJiBhLm5hbWUpIHtcbiAgICAgICAgICAgICAgdmFyIG4gPSBidWlsZFR5cGUoYSk7XG4gICAgICAgICAgICAgIGlmIChuKSB7XG4gICAgICAgICAgICAgICAgci5zZXQoYS5uYW1lLCBuKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdDtcbiAgICAgIH0pKGUuc2NoZW1hKTtcbiAgICAgIHIgPSBhLnF1ZXJ5IHx8IHI7XG4gICAgICB0ID0gYS5tdXRhdGlvbiB8fCB0O1xuICAgICAgaSA9IGEuc3Vic2NyaXB0aW9uIHx8IGk7XG4gICAgICBpZiAoYS50eXBlcykge1xuICAgICAgICB0aGlzLnNjaGVtYSA9IGE7XG4gICAgICB9XG4gICAgfVxuICAgIHRoaXMudXBkYXRlcyA9IHtcbiAgICAgIFt0XTogZS51cGRhdGVzICYmIGUudXBkYXRlcy5NdXRhdGlvbiB8fCB7fSxcbiAgICAgIFtpXTogZS51cGRhdGVzICYmIGUudXBkYXRlcy5TdWJzY3JpcHRpb24gfHwge31cbiAgICB9O1xuICAgIHRoaXMucm9vdEZpZWxkcyA9IHtcbiAgICAgIHF1ZXJ5OiByLFxuICAgICAgbXV0YXRpb246IHQsXG4gICAgICBzdWJzY3JpcHRpb246IGlcbiAgICB9O1xuICAgIHRoaXMucm9vdE5hbWVzID0ge1xuICAgICAgW3JdOiBcInF1ZXJ5XCIsXG4gICAgICBbdF06IFwibXV0YXRpb25cIixcbiAgICAgIFtpXTogXCJzdWJzY3JpcHRpb25cIlxuICAgIH07XG4gICAgdGhpcy5kYXRhID0gKG4gPSByLCB7XG4gICAgICBkZWZlcjogITEsXG4gICAgICBnYzogbmV3IFNldCxcbiAgICAgIHBlcnNpc3Q6IG5ldyBTZXQsXG4gICAgICBxdWVyeVJvb3RLZXk6IG4sXG4gICAgICByZWZDb3VudDogbmV3IE1hcCxcbiAgICAgIHJlZkxvY2s6IG5ldyBNYXAsXG4gICAgICBsaW5rczoge1xuICAgICAgICBvcHRpbWlzdGljOiBuZXcgTWFwLFxuICAgICAgICBiYXNlOiBuZXcgTWFwXG4gICAgICB9LFxuICAgICAgcmVjb3Jkczoge1xuICAgICAgICBvcHRpbWlzdGljOiBuZXcgTWFwLFxuICAgICAgICBiYXNlOiBuZXcgTWFwXG4gICAgICB9LFxuICAgICAgZGVmZXJyZWRLZXlzOiBuZXcgU2V0LFxuICAgICAgY29tbXV0YXRpdmVLZXlzOiBuZXcgU2V0LFxuICAgICAgb3B0aW1pc3RpY09yZGVyOiBbXSxcbiAgICAgIHN0b3JhZ2U6IG51bGxcbiAgICB9KTtcbiAgICB2YXIgbjtcbiAgICBpZiAodGhpcy5zY2hlbWEgJiYgXCJwcm9kdWN0aW9uXCIgIT09IHByb2Nlc3MuZW52Lk5PREVfRU5WKSB7XG4gICAgICAhZnVuY3Rpb24gZXhwZWN0VmFsaWRLZXlpbmdDb25maWcoZSwgcikge1xuICAgICAgICBpZiAoXCJwcm9kdWN0aW9uXCIgIT09IHByb2Nlc3MuZW52Lk5PREVfRU5WKSB7XG4gICAgICAgICAgZm9yICh2YXIgdCBpbiByKSB7XG4gICAgICAgICAgICBpZiAoXCJwcm9kdWN0aW9uXCIgIT09IHByb2Nlc3MuZW52Lk5PREVfRU5WKSB7XG4gICAgICAgICAgICAgIGlmICghZS50eXBlcy5oYXModCkpIHtcbiAgICAgICAgICAgICAgICB3YXJuKFwiSW52YWxpZCBPYmplY3QgdHlwZTogVGhlIHR5cGUgYFwiICsgdCArIFwiYCBpcyBub3QgYW4gb2JqZWN0IGluIHRoZSBkZWZpbmVkIHNjaGVtYSwgYnV0IHRoZSBga2V5c2Agb3B0aW9uIGlzIHJlZmVyZW5jaW5nIGl0LlwiLCAyMCk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0odGhpcy5zY2hlbWEsIHRoaXMua2V5cyk7XG4gICAgICAhZnVuY3Rpb24gZXhwZWN0VmFsaWRVcGRhdGVzQ29uZmlnKGUsIHIpIHtcbiAgICAgICAgaWYgKFwicHJvZHVjdGlvblwiID09PSBwcm9jZXNzLmVudi5OT0RFX0VOVikge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZS5tdXRhdGlvbikge1xuICAgICAgICAgIHZhciB0ID0gZS50eXBlcy5nZXQoZS5tdXRhdGlvbikuZmllbGRzKCk7XG4gICAgICAgICAgdmFyIGkgPSByW2UubXV0YXRpb25dIHx8IHt9O1xuICAgICAgICAgIGZvciAodmFyIGEgaW4gaSkge1xuICAgICAgICAgICAgaWYgKFwicHJvZHVjdGlvblwiICE9PSBwcm9jZXNzLmVudi5OT0RFX0VOVikge1xuICAgICAgICAgICAgICBpZiAodm9pZCAwID09PSB0W2FdKSB7XG4gICAgICAgICAgICAgICAgd2FybihcIkludmFsaWQgbXV0YXRpb24gZmllbGQ6IGBcIiArIGEgKyBcImAgaXMgbm90IGluIHRoZSBkZWZpbmVkIHNjaGVtYSwgYnV0IHRoZSBgdXBkYXRlcy5NdXRhdGlvbmAgb3B0aW9uIGlzIHJlZmVyZW5jaW5nIGl0LlwiLCAyMSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGUuc3Vic2NyaXB0aW9uKSB7XG4gICAgICAgICAgdmFyIG4gPSBlLnR5cGVzLmdldChlLnN1YnNjcmlwdGlvbikuZmllbGRzKCk7XG4gICAgICAgICAgdmFyIG8gPSByW2Uuc3Vic2NyaXB0aW9uXSB8fCB7fTtcbiAgICAgICAgICBmb3IgKHZhciBzIGluIG8pIHtcbiAgICAgICAgICAgIGlmIChcInByb2R1Y3Rpb25cIiAhPT0gcHJvY2Vzcy5lbnYuTk9ERV9FTlYpIHtcbiAgICAgICAgICAgICAgaWYgKHZvaWQgMCA9PT0gbltzXSkge1xuICAgICAgICAgICAgICAgIHdhcm4oXCJJbnZhbGlkIHN1YnNjcmlwdGlvbiBmaWVsZDogYFwiICsgcyArIFwiYCBpcyBub3QgaW4gdGhlIGRlZmluZWQgc2NoZW1hLCBidXQgdGhlIGB1cGRhdGVzLlN1YnNjcmlwdGlvbmAgb3B0aW9uIGlzIHJlZmVyZW5jaW5nIGl0LlwiLCAyMik7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0odGhpcy5zY2hlbWEsIHRoaXMudXBkYXRlcyk7XG4gICAgICAhZnVuY3Rpb24gZXhwZWN0VmFsaWRSZXNvbHZlcnNDb25maWcoZSwgcikge1xuICAgICAgICBpZiAoXCJwcm9kdWN0aW9uXCIgPT09IHByb2Nlc3MuZW52Lk5PREVfRU5WKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGZvciAodmFyIHQgaW4gcikge1xuICAgICAgICAgIGlmIChcIlF1ZXJ5XCIgPT09IHQpIHtcbiAgICAgICAgICAgIGlmIChlLnF1ZXJ5KSB7XG4gICAgICAgICAgICAgIHZhciBpID0gZS50eXBlcy5nZXQoZS5xdWVyeSkuZmllbGRzKCk7XG4gICAgICAgICAgICAgIGZvciAodmFyIGEgaW4gci5RdWVyeSkge1xuICAgICAgICAgICAgICAgIGlmICghaVthXSkge1xuICAgICAgICAgICAgICAgICAgd2FybkFib3V0UmVzb2x2ZXIoXCJRdWVyeS5cIiArIGEpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgd2FybkFib3V0UmVzb2x2ZXIoXCJRdWVyeVwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2UgaWYgKCFlLnR5cGVzLmhhcyh0KSkge1xuICAgICAgICAgICAgd2FybkFib3V0UmVzb2x2ZXIodCk7XG4gICAgICAgICAgfSBlbHNlIGlmIChcIklOVEVSRkFDRVwiID09PSBlLnR5cGVzLmdldCh0KS5raW5kIHx8IFwiVU5JT05cIiA9PT0gZS50eXBlcy5nZXQodCkua2luZCkge1xuICAgICAgICAgICAgcyA9IHQsIHYgPSBlLnR5cGVzLmdldCh0KS5raW5kLCBcInByb2R1Y3Rpb25cIiAhPT0gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgJiYgd2FybihgSW52YWxpZCByZXNvbHZlcjogXFxgJHtzfVxcYCBkb2VzIG5vdCBtYXRjaCB0byBhIGNvbmNyZXRlIHR5cGUgaW4gdGhlIHNjaGVtYSwgYnV0IHRoZSBcXGByZXNvbHZlcnNcXGAgb3B0aW9uIGlzIHJlZmVyZW5jaW5nIGl0LiBJbXBsZW1lbnQgdGhlIHJlc29sdmVyIGZvciB0aGUgdHlwZXMgdGhhdCAke1wiVU5JT05cIiA9PT0gdiA/IFwibWFrZSB1cCB0aGUgdW5pb25cIiA6IFwiaW1wbGVtZW50IHRoZSBpbnRlcmZhY2VcIn0gaW5zdGVhZC5gLCAyNik7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHZhciBuID0gZS50eXBlcy5nZXQodCkuZmllbGRzKCk7XG4gICAgICAgICAgICBmb3IgKHZhciBvIGluIHJbdF0pIHtcbiAgICAgICAgICAgICAgaWYgKCFuW29dKSB7XG4gICAgICAgICAgICAgICAgd2FybkFib3V0UmVzb2x2ZXIodCArIFwiLlwiICsgbyk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHMsIHY7XG4gICAgICB9KHRoaXMuc2NoZW1hLCB0aGlzLnJlc29sdmVycyk7XG4gICAgICAhZnVuY3Rpb24gZXhwZWN0VmFsaWRPcHRpbWlzdGljTXV0YXRpb25zQ29uZmlnKGUsIHIpIHtcbiAgICAgICAgaWYgKFwicHJvZHVjdGlvblwiID09PSBwcm9jZXNzLmVudi5OT0RFX0VOVikge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZS5tdXRhdGlvbikge1xuICAgICAgICAgIHZhciB0ID0gZS50eXBlcy5nZXQoZS5tdXRhdGlvbikuZmllbGRzKCk7XG4gICAgICAgICAgZm9yICh2YXIgaSBpbiByKSB7XG4gICAgICAgICAgICBpZiAoXCJwcm9kdWN0aW9uXCIgIT09IHByb2Nlc3MuZW52Lk5PREVfRU5WKSB7XG4gICAgICAgICAgICAgIGlmICghdFtpXSkge1xuICAgICAgICAgICAgICAgIHdhcm4oYEludmFsaWQgb3B0aW1pc3RpYyBtdXRhdGlvbiBmaWVsZDogXFxgJHtpfVxcYCBpcyBub3QgYSBtdXRhdGlvbiBmaWVsZCBpbiB0aGUgZGVmaW5lZCBzY2hlbWEsIGJ1dCB0aGUgXFxgb3B0aW1pc3RpY1xcYCBvcHRpb24gaXMgcmVmZXJlbmNpbmcgaXQuYCwgMjQpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9KHRoaXMuc2NoZW1hLCB0aGlzLm9wdGltaXN0aWNNdXRhdGlvbnMpO1xuICAgIH1cbiAgfVxuICBfX2luaXQoKSB7XG4gICAgdGhpcy5rZXlPZkZpZWxkID0ga2V5T2ZGaWVsZDtcbiAgfVxuICBrZXlPZkVudGl0eShlKSB7XG4gICAgaWYgKEQuY3VycmVudCAmJiBlID09PSBELmN1cnJlbnQucGFyZW50KSB7XG4gICAgICByZXR1cm4gRC5jdXJyZW50LnBhcmVudEtleTtcbiAgICB9XG4gICAgaWYgKG51bGwgPT0gZSB8fCBcInN0cmluZ1wiID09IHR5cGVvZiBlKSB7XG4gICAgICByZXR1cm4gZSB8fCBudWxsO1xuICAgIH1cbiAgICBpZiAoIWUuX190eXBlbmFtZSkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIGlmICh0aGlzLnJvb3ROYW1lc1tlLl9fdHlwZW5hbWVdKSB7XG4gICAgICByZXR1cm4gZS5fX3R5cGVuYW1lO1xuICAgIH1cbiAgICB2YXIgcjtcbiAgICBpZiAodGhpcy5rZXlzW2UuX190eXBlbmFtZV0pIHtcbiAgICAgIHIgPSB0aGlzLmtleXNbZS5fX3R5cGVuYW1lXShlKTtcbiAgICB9IGVsc2UgaWYgKG51bGwgIT0gZS5pZCkge1xuICAgICAgciA9IGAke2UuaWR9YDtcbiAgICB9IGVsc2UgaWYgKG51bGwgIT0gZS5faWQpIHtcbiAgICAgIHIgPSBgJHtlLl9pZH1gO1xuICAgIH1cbiAgICByZXR1cm4gciA/IGAke2UuX190eXBlbmFtZX06JHtyfWAgOiBudWxsO1xuICB9XG4gIHJlc29sdmUoZSwgciwgdCkge1xuICAgIHZhciBpID0ga2V5T2ZGaWVsZChyLCB0KTtcbiAgICB2YXIgYSA9IHRoaXMua2V5T2ZFbnRpdHkoZSk7XG4gICAgaWYgKCFhKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgdmFyIG4gPSByZWFkUmVjb3JkKGEsIGkpO1xuICAgIGlmICh2b2lkIDAgIT09IG4pIHtcbiAgICAgIHJldHVybiBuO1xuICAgIH1cbiAgICByZXR1cm4gcmVhZExpbmsoYSwgaSkgfHwgbnVsbDtcbiAgfVxuICBfX2luaXQyKCkge1xuICAgIHRoaXMucmVzb2x2ZUZpZWxkQnlLZXkgPSB0aGlzLnJlc29sdmU7XG4gIH1cbiAgaW52YWxpZGF0ZShlLCByLCB0KSB7XG4gICAgdmFyIGkgPSB0aGlzLmtleU9mRW50aXR5KGUpO1xuICAgIGludmFyaWFudChpLCBcInByb2R1Y3Rpb25cIiAhPT0gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgPyBcIkNhbid0IGdlbmVyYXRlIGEga2V5IGZvciBpbnZhbGlkYXRlKC4uLikuXFxuWW91IGhhdmUgdG8gcGFzcyBhbiBpZCBvciBfaWQgZmllbGQgb3IgY3JlYXRlIGEgY3VzdG9tIGBrZXlzYCBmaWVsZCBmb3IgYFwiICsgdHlwZW9mIGUgPT0gXCJvYmplY3RcIiA/IGUuX190eXBlbmFtZSA6IGUgKyBcImAuXCIgOiBcIlwiLCAxOSk7XG4gICAgKChlLCByLCB0KSA9PiB7XG4gICAgICB2YXIgaSA9IHIgPyBbIHtcbiAgICAgICAgZmllbGRLZXk6IGtleU9mRmllbGQociwgdClcbiAgICAgIH0gXSA6IGluc3BlY3RGaWVsZHMoZSk7XG4gICAgICBmb3IgKHZhciBhID0gMCwgbiA9IGkubGVuZ3RoOyBhIDwgbjsgYSsrKSB7XG4gICAgICAgIHZhciB7ZmllbGRLZXk6IG99ID0gaVthXTtcbiAgICAgICAgaWYgKHZvaWQgMCAhPT0gcmVhZExpbmsoZSwgbykpIHtcbiAgICAgICAgICB3cml0ZUxpbmsoZSwgbywgdm9pZCAwKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB3cml0ZVJlY29yZChlLCBvLCB2b2lkIDApO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSkoaSwgciwgdCk7XG4gIH1cbiAgaW5zcGVjdEZpZWxkcyhlKSB7XG4gICAgdmFyIHIgPSB0aGlzLmtleU9mRW50aXR5KGUpO1xuICAgIHJldHVybiByID8gaW5zcGVjdEZpZWxkcyhyKSA6IFtdO1xuICB9XG4gIHVwZGF0ZVF1ZXJ5KGUsIGkpIHtcbiAgICB2YXIgYSA9IHIoZS5xdWVyeSwgZS52YXJpYWJsZXMpO1xuICAgIGEucXVlcnkgPSB0KGEucXVlcnkpO1xuICAgIHZhciBuID0gaSh0aGlzLnJlYWRRdWVyeShhKSk7XG4gICAgaWYgKG51bGwgIT09IG4pIHtcbiAgICAgIHN0YXJ0V3JpdGUodGhpcywgYSwgbik7XG4gICAgfVxuICB9XG4gIHJlYWRRdWVyeShlKSB7XG4gICAgdmFyIGkgPSByKGUucXVlcnksIGUudmFyaWFibGVzKTtcbiAgICBpLnF1ZXJ5ID0gdChpLnF1ZXJ5KTtcbiAgICByZXR1cm4gcmVhZCh0aGlzLCBpKS5kYXRhO1xuICB9XG4gIHJlYWRGcmFnbWVudChlLCByLCBpLCBhKSB7XG4gICAgcmV0dXJuIHJlYWRGcmFnbWVudCh0aGlzLCB0KGUpLCByLCBpLCBhKTtcbiAgfVxuICB3cml0ZUZyYWdtZW50KGUsIHIsIGksIGEpIHtcbiAgICAoKGUsIHIsIHQsIGksIGEpID0+IHtcbiAgICAgIHZhciBuID0gZ2V0RnJhZ21lbnRzKHIpO1xuICAgICAgdmFyIG87XG4gICAgICBpZiAoYSkge1xuICAgICAgICBpZiAoIShvID0gblthXSkpIHtcbiAgICAgICAgICBcInByb2R1Y3Rpb25cIiAhPT0gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgJiYgd2FybihcIndyaXRlRnJhZ21lbnQoLi4uKSB3YXMgY2FsbGVkIHdpdGggYSBmcmFnbWVudCBuYW1lIHRoYXQgZG9lcyBub3QgZXhpc3QuXFxuWW91IHByb3ZpZGVkIFwiICsgYSArIFwiIGJ1dCBjb3VsZCBvbmx5IGZpbmQgXCIgKyBPYmplY3Qua2V5cyhuKS5qb2luKFwiLCBcIikgKyBcIi5cIiwgMTEpO1xuICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKCEobyA9IG5bT2JqZWN0LmtleXMobilbMF1dKSkge1xuICAgICAgICBcInByb2R1Y3Rpb25cIiAhPT0gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgJiYgd2FybihcIndyaXRlRnJhZ21lbnQoLi4uKSB3YXMgY2FsbGVkIHdpdGggYW4gZW1wdHkgZnJhZ21lbnQuXFxuWW91IGhhdmUgdG8gY2FsbCBpdCB3aXRoIGF0IGxlYXN0IG9uZSBmcmFnbWVudCBpbiB5b3VyIEdyYXBoUUwgZG9jdW1lbnQuXCIsIDExKTtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG4gICAgICB2YXIgcyA9IGdldEZyYWdtZW50VHlwZU5hbWUobyk7XG4gICAgICB2YXIgdiA9IHtcbiAgICAgICAgX190eXBlbmFtZTogcyxcbiAgICAgICAgLi4udFxuICAgICAgfTtcbiAgICAgIHZhciBsID0gZS5rZXlPZkVudGl0eSh2KTtcbiAgICAgIGlmICghbCkge1xuICAgICAgICByZXR1cm4gXCJwcm9kdWN0aW9uXCIgIT09IHByb2Nlc3MuZW52Lk5PREVfRU5WID8gd2FybihcIkNhbid0IGdlbmVyYXRlIGEga2V5IGZvciB3cml0ZUZyYWdtZW50KC4uLikgZGF0YS5cXG5Zb3UgaGF2ZSB0byBwYXNzIGFuIGBpZGAgb3IgYF9pZGAgZmllbGQgb3IgY3JlYXRlIGEgY3VzdG9tIGBrZXlzYCBjb25maWcgZm9yIGBcIiArIHMgKyBcImAuXCIsIDEyKSA6IHZvaWQgMDtcbiAgICAgIH1cbiAgICAgIGlmIChcInByb2R1Y3Rpb25cIiAhPT0gcHJvY2Vzcy5lbnYuTk9ERV9FTlYpIHtcbiAgICAgICAgcHVzaERlYnVnTm9kZShzLCBvKTtcbiAgICAgIH1cbiAgICAgIHZhciB1ID0gbWFrZUNvbnRleHQoZSwgaSB8fCB7fSwgbiwgcywgbCwgdm9pZCAwKTtcbiAgICAgIHdyaXRlU2VsZWN0aW9uKHUsIGwsIGdldFNlbGVjdGlvblNldChvKSwgdik7XG4gICAgICBpZiAoXCJwcm9kdWN0aW9uXCIgIT09IHByb2Nlc3MuZW52Lk5PREVfRU5WKSB7XG4gICAgICAgIHBvcERlYnVnTm9kZSgpO1xuICAgICAgfVxuICAgIH0pKHRoaXMsIHQoZSksIHIsIGksIGEpO1xuICB9XG4gIGxpbmsoZSwgciwgdCwgaSkge1xuICAgIHZhciBhID0gdm9pZCAwICE9PSBpID8gdCA6IG51bGw7XG4gICAgdmFyIG4gPSB2b2lkIDAgIT09IGkgPyBpIDogdDtcbiAgICB2YXIgbyA9IGVuc3VyZUxpbmsodGhpcywgZSk7XG4gICAgaWYgKFwic3RyaW5nXCIgPT0gdHlwZW9mIG8pIHtcbiAgICAgIHdyaXRlTGluayhvLCBrZXlPZkZpZWxkKHIsIGEpLCBlbnN1cmVMaW5rKHRoaXMsIG4pKTtcbiAgICB9XG4gIH1cbn1cblxudmFyIHF1ZXJ5ID0gKGUsIHIsIHQsIGksIGEpID0+IHtcbiAgaW5pdERhdGFTdGF0ZShcInJlYWRcIiwgZS5kYXRhLCBhKTtcbiAgdmFyIG4gPSByZWFkKGUsIHIsIHQsIGkpO1xuICBjbGVhckRhdGFTdGF0ZSgpO1xuICByZXR1cm4gbjtcbn07XG5cbnZhciByZWFkID0gKGUsIHIsIHQsIGkpID0+IHtcbiAgdmFyIGEgPSBnZXRNYWluT3BlcmF0aW9uKHIucXVlcnkpO1xuICB2YXIgbiA9IGUucm9vdEZpZWxkc1thLm9wZXJhdGlvbl07XG4gIHZhciBvID0gZ2V0U2VsZWN0aW9uU2V0KGEpO1xuICB2YXIgcyA9IG1ha2VDb250ZXh0KGUsIG5vcm1hbGl6ZVZhcmlhYmxlcyhhLCByLnZhcmlhYmxlcyksIGdldEZyYWdtZW50cyhyLnF1ZXJ5KSwgbiwgbiwgITEsIGkpO1xuICBpZiAoXCJwcm9kdWN0aW9uXCIgIT09IHByb2Nlc3MuZW52Lk5PREVfRU5WKSB7XG4gICAgcHVzaERlYnVnTm9kZShuLCBhKTtcbiAgfVxuICBpZiAoIXQpIHtcbiAgICB0ID0gbWFrZURhdGEoKTtcbiAgfVxuICB2YXIgdiA9IG4gIT09IHMuc3RvcmUucm9vdEZpZWxkcy5xdWVyeSA/IHJlYWRSb290KHMsIG4sIG8sIHQpIDogcmVhZFNlbGVjdGlvbihzLCBuLCBvLCB0KTtcbiAgaWYgKFwicHJvZHVjdGlvblwiICE9PSBwcm9jZXNzLmVudi5OT0RFX0VOVikge1xuICAgIHBvcERlYnVnTm9kZSgpO1xuICB9XG4gIHJldHVybiB7XG4gICAgZGVwZW5kZW5jaWVzOiBnZXRDdXJyZW50RGVwZW5kZW5jaWVzKCksXG4gICAgcGFydGlhbDogcy5wYXJ0aWFsIHx8ICF2LFxuICAgIGRhdGE6IHYgfHwgbnVsbFxuICB9O1xufTtcblxudmFyIHJlYWRSb290ID0gKGUsIHIsIHQsIGkpID0+IHtcbiAgaWYgKFwic3RyaW5nXCIgIT0gdHlwZW9mIChlLnN0b3JlLnJvb3ROYW1lc1tyXSA/IHIgOiBpLl9fdHlwZW5hbWUpKSB7XG4gICAgcmV0dXJuIGk7XG4gIH1cbiAgdmFyIGEgPSBtYWtlU2VsZWN0aW9uSXRlcmF0b3IociwgciwgdCwgZSk7XG4gIHZhciBuO1xuICB2YXIgbyA9ICExO1xuICB2YXIgcyA9IG1ha2VEYXRhKGkpO1xuICB3aGlsZSAobiA9IGEoKSkge1xuICAgIHZhciB2ID0gZ2V0RmllbGRBbGlhcyhuKTtcbiAgICB2YXIgbCA9IGlbdl07XG4gICAgZS5fX2ludGVybmFsLnBhdGgucHVzaCh2KTtcbiAgICB2YXIgdSA9IHZvaWQgMDtcbiAgICBpZiAobi5zZWxlY3Rpb25TZXQgJiYgbnVsbCAhPT0gbCkge1xuICAgICAgdSA9IHJlYWRSb290RmllbGQoZSwgZ2V0U2VsZWN0aW9uU2V0KG4pLCBlbnN1cmVEYXRhKGwpKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdSA9IGw7XG4gICAgfVxuICAgIG8gPSBvIHx8IHUgIT09IGw7XG4gICAgaWYgKHZvaWQgMCAhPT0gdSkge1xuICAgICAgc1t2XSA9IHU7XG4gICAgfVxuICAgIGUuX19pbnRlcm5hbC5wYXRoLnBvcCgpO1xuICB9XG4gIHJldHVybiBvID8gcyA6IGk7XG59O1xuXG52YXIgcmVhZFJvb3RGaWVsZCA9IChlLCByLCB0KSA9PiB7XG4gIGlmIChBcnJheS5pc0FycmF5KHQpKSB7XG4gICAgdmFyIGkgPSBuZXcgQXJyYXkodC5sZW5ndGgpO1xuICAgIHZhciBhID0gITE7XG4gICAgZm9yICh2YXIgbiA9IDAsIG8gPSB0Lmxlbmd0aDsgbiA8IG87IG4rKykge1xuICAgICAgZS5fX2ludGVybmFsLnBhdGgucHVzaChuKTtcbiAgICAgIGlbbl0gPSByZWFkUm9vdEZpZWxkKGUsIHIsIHRbbl0pO1xuICAgICAgYSA9IGEgfHwgaVtuXSAhPT0gdFtuXTtcbiAgICAgIGUuX19pbnRlcm5hbC5wYXRoLnBvcCgpO1xuICAgIH1cbiAgICByZXR1cm4gYSA/IGkgOiB0O1xuICB9IGVsc2UgaWYgKG51bGwgPT09IHQpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICB2YXIgcyA9IGUuc3RvcmUua2V5T2ZFbnRpdHkodCk7XG4gIGlmIChudWxsICE9PSBzKSB7XG4gICAgcmV0dXJuIHJlYWRTZWxlY3Rpb24oZSwgcywgciwgdCkgfHwgbnVsbDtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gcmVhZFJvb3QoZSwgdC5fX3R5cGVuYW1lLCByLCB0KTtcbiAgfVxufTtcblxudmFyIHJlYWRGcmFnbWVudCA9IChlLCByLCB0LCBpLCBhKSA9PiB7XG4gIHZhciBuID0gZ2V0RnJhZ21lbnRzKHIpO1xuICB2YXIgbztcbiAgaWYgKGEpIHtcbiAgICBpZiAoIShvID0gblthXSkpIHtcbiAgICAgIFwicHJvZHVjdGlvblwiICE9PSBwcm9jZXNzLmVudi5OT0RFX0VOViAmJiB3YXJuKFwicmVhZEZyYWdtZW50KC4uLikgd2FzIGNhbGxlZCB3aXRoIGEgZnJhZ21lbnQgbmFtZSB0aGF0IGRvZXMgbm90IGV4aXN0LlxcbllvdSBwcm92aWRlZCBcIiArIGEgKyBcIiBidXQgY291bGQgb25seSBmaW5kIFwiICsgT2JqZWN0LmtleXMobikuam9pbihcIiwgXCIpICsgXCIuXCIsIDYpO1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGlmICghKG8gPSBuW09iamVjdC5rZXlzKG4pWzBdXSkpIHtcbiAgICAgIFwicHJvZHVjdGlvblwiICE9PSBwcm9jZXNzLmVudi5OT0RFX0VOViAmJiB3YXJuKFwicmVhZEZyYWdtZW50KC4uLikgd2FzIGNhbGxlZCB3aXRoIGFuIGVtcHR5IGZyYWdtZW50LlxcbllvdSBoYXZlIHRvIGNhbGwgaXQgd2l0aCBhdCBsZWFzdCBvbmUgZnJhZ21lbnQgaW4geW91ciBHcmFwaFFMIGRvY3VtZW50LlwiLCA2KTtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgfVxuICB2YXIgcyA9IGdldEZyYWdtZW50VHlwZU5hbWUobyk7XG4gIGlmIChcInN0cmluZ1wiICE9IHR5cGVvZiB0ICYmICF0Ll9fdHlwZW5hbWUpIHtcbiAgICB0Ll9fdHlwZW5hbWUgPSBzO1xuICB9XG4gIHZhciB2ID0gZS5rZXlPZkVudGl0eSh0KTtcbiAgaWYgKCF2KSB7XG4gICAgXCJwcm9kdWN0aW9uXCIgIT09IHByb2Nlc3MuZW52Lk5PREVfRU5WICYmIHdhcm4oXCJDYW4ndCBnZW5lcmF0ZSBhIGtleSBmb3IgcmVhZEZyYWdtZW50KC4uLikuXFxuWW91IGhhdmUgdG8gcGFzcyBhbiBgaWRgIG9yIGBfaWRgIGZpZWxkIG9yIGNyZWF0ZSBhIGN1c3RvbSBga2V5c2AgY29uZmlnIGZvciBgXCIgKyBzICsgXCJgLlwiLCA3KTtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICBpZiAoXCJwcm9kdWN0aW9uXCIgIT09IHByb2Nlc3MuZW52Lk5PREVfRU5WKSB7XG4gICAgcHVzaERlYnVnTm9kZShzLCBvKTtcbiAgfVxuICB2YXIgbCA9IG1ha2VDb250ZXh0KGUsIGkgfHwge30sIG4sIHMsIHYpO1xuICB2YXIgdSA9IHJlYWRTZWxlY3Rpb24obCwgdiwgZ2V0U2VsZWN0aW9uU2V0KG8pLCBtYWtlRGF0YSgpKSB8fCBudWxsO1xuICBpZiAoXCJwcm9kdWN0aW9uXCIgIT09IHByb2Nlc3MuZW52Lk5PREVfRU5WKSB7XG4gICAgcG9wRGVidWdOb2RlKCk7XG4gIH1cbiAgcmV0dXJuIHU7XG59O1xuXG52YXIgcmVhZFNlbGVjdGlvbiA9IChlLCByLCB0LCBpLCBhKSA9PiB7XG4gIHZhciB7c3RvcmU6IG59ID0gZTtcbiAgdmFyIG8gPSByID09PSBuLnJvb3RGaWVsZHMucXVlcnk7XG4gIHZhciBzID0gYSAmJiBuLmtleU9mRW50aXR5KGEpIHx8IHI7XG4gIGlmIChcInByb2R1Y3Rpb25cIiAhPT0gcHJvY2Vzcy5lbnYuTk9ERV9FTlYpIHtcbiAgICBpZiAoIW8gJiYgZS5zdG9yZS5yb290TmFtZXNbc10pIHtcbiAgICAgIHdhcm4oXCJJbnZhbGlkIHJvb3QgdHJhdmVyc2FsOiBBIHNlbGVjdGlvbiB3YXMgYmVpbmcgcmVhZCBvbiBgXCIgKyBzICsgXCJgIHdoaWNoIGlzIGFuIHVuY2FjaGVkIHJvb3QgdHlwZS5cXG5UaGUgYFwiICsgZS5zdG9yZS5yb290RmllbGRzLm11dGF0aW9uICsgXCJgIGFuZCBgXCIgKyBlLnN0b3JlLnJvb3RGaWVsZHMuc3Vic2NyaXB0aW9uICsgXCJgIHR5cGVzIGFyZSBzcGVjaWFsIE9wZXJhdGlvbiBSb290IFR5cGVzIGFuZCBjYW5ub3QgYmUgcmVhZCBiYWNrIGZyb20gdGhlIGNhY2hlLlwiLCAyNSk7XG4gICAgfVxuICB9XG4gIHZhciB2ID0gIW8gPyByZWFkUmVjb3JkKHMsIFwiX190eXBlbmFtZVwiKSB8fCBhICYmIGEuX190eXBlbmFtZSA6IHI7XG4gIGlmIChcInN0cmluZ1wiICE9IHR5cGVvZiB2KSB7XG4gICAgcmV0dXJuO1xuICB9IGVsc2UgaWYgKGEgJiYgdiAhPT0gYS5fX3R5cGVuYW1lKSB7XG4gICAgXCJwcm9kdWN0aW9uXCIgIT09IHByb2Nlc3MuZW52Lk5PREVfRU5WICYmIHdhcm4oXCJJbnZhbGlkIHJlc29sdmVyIGRhdGE6IFRoZSByZXNvbHZlciBhdCBgXCIgKyBzICsgXCJgIHJldHVybmVkIGFuIGludmFsaWQgdHlwZW5hbWUgdGhhdCBjb3VsZCBub3QgYmUgcmVjb25jaWxlZCB3aXRoIHRoZSBjYWNoZS5cIiwgOCk7XG4gICAgcmV0dXJuO1xuICB9XG4gIHZhciBsID0gbWFrZVNlbGVjdGlvbkl0ZXJhdG9yKHYsIHMsIHQsIGUpO1xuICB2YXIgdSA9ICExO1xuICB2YXIgZCA9ICExO1xuICB2YXIgcCA9IHYgIT09IGkuX190eXBlbmFtZTtcbiAgdmFyIGM7XG4gIHZhciBmID0gbWFrZURhdGEoaSk7XG4gIHdoaWxlICh2b2lkIDAgIT09IChjID0gbCgpKSkge1xuICAgIHZhciB5ID0gZ2V0TmFtZShjKTtcbiAgICB2YXIgaCA9IGdldEZpZWxkQXJndW1lbnRzKGMsIGUudmFyaWFibGVzKTtcbiAgICB2YXIgbSA9IGdldEZpZWxkQWxpYXMoYyk7XG4gICAgdmFyIGcgPSBrZXlPZkZpZWxkKHksIGgpO1xuICAgIHZhciBfID0gam9pbktleXMocywgZyk7XG4gICAgdmFyIE4gPSByZWFkUmVjb3JkKHMsIGcpO1xuICAgIHZhciBrID0gYSA/IGFbeV0gOiB2b2lkIDA7XG4gICAgdmFyIEUgPSBuLnJlc29sdmVyc1t2XTtcbiAgICBpZiAoXCJwcm9kdWN0aW9uXCIgIT09IHByb2Nlc3MuZW52Lk5PREVfRU5WICYmIG4uc2NoZW1hICYmIHYpIHtcbiAgICAgIGlzRmllbGRBdmFpbGFibGVPblR5cGUobi5zY2hlbWEsIHYsIHkpO1xuICAgIH1cbiAgICBlLl9faW50ZXJuYWwucGF0aC5wdXNoKG0pO1xuICAgIHZhciBPID0gdm9pZCAwO1xuICAgIGlmIChcIl9fdHlwZW5hbWVcIiA9PT0geSkge1xuICAgICAgTyA9IHY7XG4gICAgfSBlbHNlIGlmICh2b2lkIDAgIT09IGsgJiYgdm9pZCAwID09PSBjLnNlbGVjdGlvblNldCkge1xuICAgICAgTyA9IGs7XG4gICAgfSBlbHNlIGlmIChcInJlYWRcIiA9PT0gZ2V0Q3VycmVudE9wZXJhdGlvbigpICYmIEUgJiYgXCJmdW5jdGlvblwiID09IHR5cGVvZiBFW3ldKSB7XG4gICAgICB1cGRhdGVDb250ZXh0KGUsIGYsIHYsIHMsIF8sIHkpO1xuICAgICAgaWYgKHZvaWQgMCAhPT0gTikge1xuICAgICAgICBmW21dID0gTjtcbiAgICAgIH1cbiAgICAgIE8gPSBFW3ldKGYsIGggfHwge30sIG4sIGUpO1xuICAgICAgaWYgKGMuc2VsZWN0aW9uU2V0KSB7XG4gICAgICAgIE8gPSByZXNvbHZlUmVzb2x2ZXJSZXN1bHQoZSwgdiwgeSwgXywgZ2V0U2VsZWN0aW9uU2V0KGMpLCB2b2lkIDAgIT09IGZbbV0gPyBmW21dIDogaVttXSwgTywgb3duc0RhdGEoaSkpO1xuICAgICAgfVxuICAgICAgaWYgKG4uc2NoZW1hICYmIG51bGwgPT09IE8gJiYgIWlzRmllbGROdWxsYWJsZShuLnNjaGVtYSwgdiwgeSkpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoIWMuc2VsZWN0aW9uU2V0KSB7XG4gICAgICBPID0gTjtcbiAgICB9IGVsc2UgaWYgKHZvaWQgMCAhPT0gaykge1xuICAgICAgTyA9IHJlc29sdmVSZXNvbHZlclJlc3VsdChlLCB2LCB5LCBfLCBnZXRTZWxlY3Rpb25TZXQoYyksIHZvaWQgMCAhPT0gZlttXSA/IGZbbV0gOiBpW21dLCBrLCBvd25zRGF0YShpKSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciB3ID0gcmVhZExpbmsocywgZyk7XG4gICAgICBpZiAodm9pZCAwICE9PSB3KSB7XG4gICAgICAgIE8gPSByZXNvbHZlTGluayhlLCB3LCB2LCB5LCBnZXRTZWxlY3Rpb25TZXQoYyksIHZvaWQgMCAhPT0gZlttXSA/IGZbbV0gOiBpW21dLCBvd25zRGF0YShpKSk7XG4gICAgICB9IGVsc2UgaWYgKFwib2JqZWN0XCIgPT0gdHlwZW9mIE4gJiYgbnVsbCAhPT0gTikge1xuICAgICAgICBPID0gTjtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKHZvaWQgMCA9PT0gTyAmJiBxLmN1cnJlbnQpIHtcbiAgICAgIHUgPSAhMDtcbiAgICB9IGVsc2UgaWYgKHZvaWQgMCA9PT0gTyAmJiAobi5zY2hlbWEgJiYgaXNGaWVsZE51bGxhYmxlKG4uc2NoZW1hLCB2LCB5KSB8fCBnZXRGaWVsZEVycm9yKGUpKSkge1xuICAgICAgZCA9ICEwO1xuICAgICAgTyA9IG51bGw7XG4gICAgfSBlbHNlIGlmICh2b2lkIDAgPT09IE8pIHtcbiAgICAgIGUuX19pbnRlcm5hbC5wYXRoLnBvcCgpO1xuICAgICAgcmV0dXJuO1xuICAgIH0gZWxzZSB7XG4gICAgICB1ID0gdSB8fCBcIl9fdHlwZW5hbWVcIiAhPT0geTtcbiAgICB9XG4gICAgZS5fX2ludGVybmFsLnBhdGgucG9wKCk7XG4gICAgcCA9IHAgfHwgTyAhPT0gaVttXTtcbiAgICBpZiAodm9pZCAwICE9PSBPKSB7XG4gICAgICBmW21dID0gTztcbiAgICB9XG4gIH1cbiAgZS5wYXJ0aWFsID0gZS5wYXJ0aWFsIHx8IGQ7XG4gIHJldHVybiBvICYmIGQgJiYgIXUgPyB2b2lkIDAgOiBwID8gZiA6IGk7XG59O1xuXG52YXIgcmVzb2x2ZVJlc29sdmVyUmVzdWx0ID0gKGUsIHIsIHQsIGksIGEsIG4sIG8sIHMpID0+IHtcbiAgaWYgKEFycmF5LmlzQXJyYXkobykpIHtcbiAgICB2YXIge3N0b3JlOiB2fSA9IGU7XG4gICAgdmFyIGwgPSB2LnNjaGVtYSA/IGlzTGlzdE51bGxhYmxlKHYuc2NoZW1hLCByLCB0KSA6ICExO1xuICAgIHZhciB1ID0gbmV3IEFycmF5KG8ubGVuZ3RoKTtcbiAgICB2YXIgZCA9ICFBcnJheS5pc0FycmF5KG4pIHx8IG8ubGVuZ3RoICE9PSBuLmxlbmd0aDtcbiAgICBmb3IgKHZhciBwID0gMCwgYyA9IG8ubGVuZ3RoOyBwIDwgYzsgcCsrKSB7XG4gICAgICBlLl9faW50ZXJuYWwucGF0aC5wdXNoKHApO1xuICAgICAgdmFyIGYgPSByZXNvbHZlUmVzb2x2ZXJSZXN1bHQoZSwgciwgdCwgam9pbktleXMoaSwgYCR7cH1gKSwgYSwgbnVsbCAhPSBuID8gbltwXSA6IHZvaWQgMCwgb1twXSwgcyk7XG4gICAgICBlLl9faW50ZXJuYWwucGF0aC5wb3AoKTtcbiAgICAgIGlmICh2b2lkIDAgPT09IGYgJiYgIWwpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZS5wYXJ0aWFsID0gZS5wYXJ0aWFsIHx8IHZvaWQgMCA9PT0gZiAmJiBsO1xuICAgICAgICB1W3BdID0gbnVsbCAhPSBmID8gZiA6IG51bGw7XG4gICAgICAgIGQgPSBkIHx8IHVbcF0gIT09IG5bcF07XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBkID8gdSA6IG47XG4gIH0gZWxzZSBpZiAobnVsbCA9PSBvKSB7XG4gICAgcmV0dXJuIG87XG4gIH0gZWxzZSBpZiAocyAmJiBudWxsID09PSBuKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH0gZWxzZSBpZiAoaXNEYXRhT3JLZXkobykpIHtcbiAgICB2YXIgeSA9IG4gfHwgbWFrZURhdGEoKTtcbiAgICByZXR1cm4gXCJzdHJpbmdcIiA9PSB0eXBlb2YgbyA/IHJlYWRTZWxlY3Rpb24oZSwgbywgYSwgeSkgOiByZWFkU2VsZWN0aW9uKGUsIGksIGEsIHksIG8pO1xuICB9IGVsc2Uge1xuICAgIFwicHJvZHVjdGlvblwiICE9PSBwcm9jZXNzLmVudi5OT0RFX0VOViAmJiB3YXJuKFwiSW52YWxpZCByZXNvbHZlciB2YWx1ZTogVGhlIGZpZWxkIGF0IGBcIiArIGkgKyBcImAgaXMgYSBzY2FsYXIgKG51bWJlciwgYm9vbGVhbiwgZXRjKSwgYnV0IHRoZSBHcmFwaFFMIHF1ZXJ5IGV4cGVjdHMgYSBzZWxlY3Rpb24gc2V0IGZvciB0aGlzIGZpZWxkLlwiLCA5KTtcbiAgICByZXR1cm47XG4gIH1cbn07XG5cbnZhciByZXNvbHZlTGluayA9IChlLCByLCB0LCBpLCBhLCBuLCBvKSA9PiB7XG4gIGlmIChBcnJheS5pc0FycmF5KHIpKSB7XG4gICAgdmFyIHtzdG9yZTogc30gPSBlO1xuICAgIHZhciB2ID0gcy5zY2hlbWEgPyBpc0xpc3ROdWxsYWJsZShzLnNjaGVtYSwgdCwgaSkgOiAhMTtcbiAgICB2YXIgbCA9IG5ldyBBcnJheShyLmxlbmd0aCk7XG4gICAgdmFyIHUgPSAhQXJyYXkuaXNBcnJheShuKSB8fCBsLmxlbmd0aCAhPT0gbi5sZW5ndGg7XG4gICAgZm9yICh2YXIgZCA9IDAsIHAgPSByLmxlbmd0aDsgZCA8IHA7IGQrKykge1xuICAgICAgZS5fX2ludGVybmFsLnBhdGgucHVzaChkKTtcbiAgICAgIHZhciBjID0gcmVzb2x2ZUxpbmsoZSwgcltkXSwgdCwgaSwgYSwgbnVsbCAhPSBuID8gbltkXSA6IHZvaWQgMCwgbyk7XG4gICAgICBlLl9faW50ZXJuYWwucGF0aC5wb3AoKTtcbiAgICAgIGlmICh2b2lkIDAgPT09IGMgJiYgIXYpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZS5wYXJ0aWFsID0gZS5wYXJ0aWFsIHx8IHZvaWQgMCA9PT0gYyAmJiB2O1xuICAgICAgICBsW2RdID0gYyB8fCBudWxsO1xuICAgICAgICB1ID0gdSB8fCBsW2RdICE9PSBuW2RdO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdSA/IGwgOiBuO1xuICB9IGVsc2UgaWYgKG51bGwgPT09IHIgfHwgbnVsbCA9PT0gbiAmJiBvKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgcmV0dXJuIHJlYWRTZWxlY3Rpb24oZSwgciwgYSwgbiB8fCBtYWtlRGF0YSgpKTtcbn07XG5cbnZhciBpc0RhdGFPcktleSA9IGUgPT4gXCJzdHJpbmdcIiA9PSB0eXBlb2YgZSB8fCBcIm9iamVjdFwiID09IHR5cGVvZiBlICYmIFwic3RyaW5nXCIgPT0gdHlwZW9mIGUuX190eXBlbmFtZTtcblxudmFyIGFkZENhY2hlT3V0Y29tZSA9IChlLCByKSA9PiBpKGUua2luZCwgZSwge1xuICAuLi5lLmNvbnRleHQsXG4gIG1ldGE6IHtcbiAgICAuLi5lLmNvbnRleHQubWV0YSxcbiAgICBjYWNoZU91dGNvbWU6IHJcbiAgfVxufSk7XG5cbnZhciB0b1JlcXVlc3RQb2xpY3kgPSAoZSwgcikgPT4gaShlLmtpbmQsIGUsIHtcbiAgLi4uZS5jb250ZXh0LFxuICByZXF1ZXN0UG9saWN5OiByXG59KTtcblxudmFyIGNhY2hlRXhjaGFuZ2UgPSBlID0+ICh7Zm9yd2FyZDogciwgY2xpZW50OiBkLCBkaXNwYXRjaERlYnVnOiBwfSkgPT4ge1xuICB2YXIgYyA9IG5ldyBTdG9yZShlKTtcbiAgaWYgKGUgJiYgZS5zdG9yYWdlKSB7XG4gICAgZS5zdG9yYWdlLnJlYWREYXRhKCkudGhlbigociA9PiB7XG4gICAgICAoKGUsIHIsIHQpID0+IHtcbiAgICAgICAgaW5pdERhdGFTdGF0ZShcIndyaXRlXCIsIGUsIG51bGwpO1xuICAgICAgICBmb3IgKHZhciBpIGluIHQpIHtcbiAgICAgICAgICB2YXIgYSA9IHRbaV07XG4gICAgICAgICAgaWYgKHZvaWQgMCAhPT0gYSkge1xuICAgICAgICAgICAgdmFyIHtlbnRpdHlLZXk6IG4sIGZpZWxkS2V5OiBvfSA9IGRlc2VyaWFsaXplS2V5SW5mbyhpKTtcbiAgICAgICAgICAgIGlmIChcIjpcIiA9PT0gYVswXSkge1xuICAgICAgICAgICAgICBpZiAodm9pZCAwID09PSByZWFkTGluayhuLCBvKSkge1xuICAgICAgICAgICAgICAgIHdyaXRlTGluayhuLCBvLCBKU09OLnBhcnNlKGEuc2xpY2UoMSkpKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIGlmICh2b2lkIDAgPT09IHJlYWRSZWNvcmQobiwgbykpIHtcbiAgICAgICAgICAgICAgd3JpdGVSZWNvcmQobiwgbywgSlNPTi5wYXJzZShhKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNsZWFyRGF0YVN0YXRlKCk7XG4gICAgICAgIGUuc3RvcmFnZSA9IHI7XG4gICAgICB9KShjLmRhdGEsIGUuc3RvcmFnZSwgcik7XG4gICAgfSkpO1xuICB9XG4gIHZhciBmID0gbmV3IE1hcDtcbiAgdmFyIHkgPSBbXTtcbiAgdmFyIGggPSBuZXcgTWFwO1xuICB2YXIgbSA9IG5ldyBNYXA7XG4gIHZhciBnID0gbmV3IFNldDtcbiAgdmFyIF8gPSBuZXcgU2V0O1xuICB2YXIgTiA9IG5ldyBNYXA7XG4gIHZhciBrID0gbmV3IFNldDtcbiAgdmFyIEUgPSBuZXcgU2V0O1xuICB2YXIgaXNCbG9ja2VkQnlPcHRpbWlzdGljVXBkYXRlID0gZSA9PiB7XG4gICAgZm9yICh2YXIgciBvZiBlLnZhbHVlcygpKSB7XG4gICAgICBpZiAoZy5oYXMocikpIHtcbiAgICAgICAgcmV0dXJuICEwO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gITE7XG4gIH07XG4gIHZhciBjb2xsZWN0UGVuZGluZ09wZXJhdGlvbnMgPSAoZSwgcikgPT4ge1xuICAgIGlmIChyKSB7XG4gICAgICBmb3IgKHZhciB0IG9mIHIudmFsdWVzKCkpIHtcbiAgICAgICAgdmFyIGkgPSBOLmdldCh0KTtcbiAgICAgICAgaWYgKGkpIHtcbiAgICAgICAgICBmb3IgKHZhciBhIG9mIGkudmFsdWVzKCkpIHtcbiAgICAgICAgICAgIGUuYWRkKGEpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfTtcbiAgdmFyIGV4ZWN1dGVQZW5kaW5nT3BlcmF0aW9ucyA9IChlLCByKSA9PiB7XG4gICAgZm9yICh2YXIgdCBvZiByLnZhbHVlcygpKSB7XG4gICAgICBpZiAodCAhPT0gZS5rZXkpIHtcbiAgICAgICAgdmFyIGkgPSBoLmdldCh0KTtcbiAgICAgICAgaWYgKGkpIHtcbiAgICAgICAgICBpZiAoXCJxdWVyeVwiID09PSBlLmtpbmQpIHtcbiAgICAgICAgICAgIEUuYWRkKHQpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBoLmRlbGV0ZSh0KTtcbiAgICAgICAgICB2YXIgYSA9IFwiY2FjaGUtZmlyc3RcIjtcbiAgICAgICAgICBpZiAoXy5oYXModCkpIHtcbiAgICAgICAgICAgIF8uZGVsZXRlKHQpO1xuICAgICAgICAgICAgYSA9IFwiY2FjaGUtYW5kLW5ldHdvcmtcIjtcbiAgICAgICAgICB9XG4gICAgICAgICAgZC5yZWV4ZWN1dGVPcGVyYXRpb24odG9SZXF1ZXN0UG9saWN5KGksIGEpKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICB2YXIgbiA9IGs7XG4gICAgaWYgKFwicXVlcnlcIiA9PT0gZS5raW5kKSB7XG4gICAgICAoayA9IEUpLmFkZChlLmtleSk7XG4gICAgfVxuICAgIChFID0gbikuY2xlYXIoKTtcbiAgfTtcbiAgdmFyIHByZXBhcmVGb3J3YXJkZWRPcGVyYXRpb24gPSBlID0+IHtcbiAgICBpZiAoXCJxdWVyeVwiID09PSBlLmtpbmQpIHtcbiAgICAgIHJlc2VydmVMYXllcihjLmRhdGEsIGUua2V5KTtcbiAgICB9IGVsc2UgaWYgKFwidGVhcmRvd25cIiA9PT0gZS5raW5kKSB7XG4gICAgICBoLmRlbGV0ZShlLmtleSk7XG4gICAgICBtLmRlbGV0ZShlLmtleSk7XG4gICAgICBub29wRGF0YVN0YXRlKGMuZGF0YSwgZS5rZXkpO1xuICAgIH0gZWxzZSBpZiAoXCJtdXRhdGlvblwiID09PSBlLmtpbmQgJiYgXCJuZXR3b3JrLW9ubHlcIiAhPT0gZS5jb250ZXh0LnJlcXVlc3RQb2xpY3kpIHtcbiAgICAgIHZhciB7ZGVwZW5kZW5jaWVzOiByfSA9ICgoZSwgciwgdCkgPT4ge1xuICAgICAgICBpZiAoXCJwcm9kdWN0aW9uXCIgIT09IHByb2Nlc3MuZW52Lk5PREVfRU5WKSB7XG4gICAgICAgICAgaW52YXJpYW50KFwibXV0YXRpb25cIiA9PT0gZ2V0TWFpbk9wZXJhdGlvbihyLnF1ZXJ5KS5vcGVyYXRpb24sIFwicHJvZHVjdGlvblwiICE9PSBwcm9jZXNzLmVudi5OT0RFX0VOViA/IFwid3JpdGVPcHRpbWlzdGljKC4uLikgd2FzIGNhbGxlZCB3aXRoIGFuIG9wZXJhdGlvbiB0aGF0IGlzIG5vdCBhIG11dGF0aW9uLlxcblRoaXMgY2FzZSBpcyB1bnN1cHBvcnRlZCBhbmQgc2hvdWxkIG5ldmVyIG9jY3VyLlwiIDogXCJcIiwgMTApO1xuICAgICAgICB9XG4gICAgICAgIGluaXREYXRhU3RhdGUoXCJ3cml0ZVwiLCBlLmRhdGEsIHQsICEwKTtcbiAgICAgICAgdmFyIGkgPSBzdGFydFdyaXRlKGUsIHIsIHt9LCB2b2lkIDAsICEwKTtcbiAgICAgICAgY2xlYXJEYXRhU3RhdGUoKTtcbiAgICAgICAgcmV0dXJuIGk7XG4gICAgICB9KShjLCBlLCBlLmtleSk7XG4gICAgICBpZiAoci5zaXplKSB7XG4gICAgICAgIGZvciAodmFyIGEgb2Ygci52YWx1ZXMoKSkge1xuICAgICAgICAgIGcuYWRkKGEpO1xuICAgICAgICB9XG4gICAgICAgIGYuc2V0KGUua2V5LCByKTtcbiAgICAgICAgdmFyIG4gPSBuZXcgU2V0O1xuICAgICAgICBjb2xsZWN0UGVuZGluZ09wZXJhdGlvbnMobiwgcik7XG4gICAgICAgIGV4ZWN1dGVQZW5kaW5nT3BlcmF0aW9ucyhlLCBuKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGkoZS5raW5kLCB7XG4gICAgICBrZXk6IGUua2V5LFxuICAgICAgcXVlcnk6IHQoZS5xdWVyeSksXG4gICAgICB2YXJpYWJsZXM6IGUudmFyaWFibGVzID8gZmlsdGVyVmFyaWFibGVzKGdldE1haW5PcGVyYXRpb24oZS5xdWVyeSksIGUudmFyaWFibGVzKSA6IGUudmFyaWFibGVzXG4gICAgfSwgZS5jb250ZXh0KTtcbiAgfTtcbiAgdmFyIHVwZGF0ZURlcGVuZGVuY2llcyA9IChlLCByKSA9PiB7XG4gICAgZm9yICh2YXIgdCBvZiByLnZhbHVlcygpKSB7XG4gICAgICB2YXIgaSA9IE4uZ2V0KHQpO1xuICAgICAgaWYgKCFpKSB7XG4gICAgICAgIE4uc2V0KHQsIGkgPSBuZXcgU2V0KTtcbiAgICAgIH1cbiAgICAgIGkuYWRkKGUua2V5KTtcbiAgICB9XG4gIH07XG4gIHZhciBvcGVyYXRpb25SZXN1bHRGcm9tQ2FjaGUgPSBlID0+IHtcbiAgICB2YXIgciA9IHF1ZXJ5KGMsIGUsIG0uZ2V0KGUua2V5KSk7XG4gICAgdmFyIHQgPSByLmRhdGEgPyAhci5wYXJ0aWFsID8gXCJoaXRcIiA6IFwicGFydGlhbFwiIDogXCJtaXNzXCI7XG4gICAgbS5zZXQoZS5rZXksIHIuZGF0YSk7XG4gICAgaC5zZXQoZS5rZXksIGUpO1xuICAgIHVwZGF0ZURlcGVuZGVuY2llcyhlLCByLmRlcGVuZGVuY2llcyk7XG4gICAgcmV0dXJuIHtcbiAgICAgIG91dGNvbWU6IHQsXG4gICAgICBvcGVyYXRpb246IGUsXG4gICAgICBkYXRhOiByLmRhdGEsXG4gICAgICBkZXBlbmRlbmNpZXM6IHIuZGVwZW5kZW5jaWVzXG4gICAgfTtcbiAgfTtcbiAgdmFyIHVwZGF0ZUNhY2hlV2l0aFJlc3VsdCA9IChlLCByKSA9PiB7XG4gICAgdmFyIHtlcnJvcjogdCwgZXh0ZW5zaW9uczogYX0gPSBlO1xuICAgIHZhciBuID0gaC5nZXQoZS5vcGVyYXRpb24ua2V5KTtcbiAgICB2YXIgbyA9IG4gPyBpKG4ua2luZCwgbiwgZS5vcGVyYXRpb24uY29udGV4dCkgOiBlLm9wZXJhdGlvbjtcbiAgICBpZiAoXCJtdXRhdGlvblwiID09PSBvLmtpbmQpIHtcbiAgICAgIHZhciBzID0gZi5nZXQoby5rZXkpO1xuICAgICAgY29sbGVjdFBlbmRpbmdPcGVyYXRpb25zKHIsIHMpO1xuICAgICAgZi5kZWxldGUoby5rZXkpO1xuICAgIH1cbiAgICByZXNlcnZlTGF5ZXIoYy5kYXRhLCBvLmtleSwgXCJzdWJzY3JpcHRpb25cIiA9PT0gby5raW5kIHx8IGUuaGFzTmV4dCk7XG4gICAgdmFyIHY7XG4gICAgdmFyIGwgPSBlLmRhdGE7XG4gICAgaWYgKGwpIHtcbiAgICAgIHZhciB1ID0gd3JpdGUoYywgbywgbCwgZS5lcnJvciwgby5rZXkpLmRlcGVuZGVuY2llcztcbiAgICAgIGNvbGxlY3RQZW5kaW5nT3BlcmF0aW9ucyhyLCB1KTtcbiAgICAgIHZhciBkID0gcXVlcnkoYywgbywgXCJxdWVyeVwiID09PSBvLmtpbmQgPyBtLmdldChvLmtleSkgfHwgbCA6IGwsIGUuZXJyb3IsIG8ua2V5KTtcbiAgICAgIGwgPSBkLmRhdGE7XG4gICAgICBpZiAoXCJxdWVyeVwiID09PSBvLmtpbmQpIHtcbiAgICAgICAgY29sbGVjdFBlbmRpbmdPcGVyYXRpb25zKHIsIHYgPSBkLmRlcGVuZGVuY2llcyk7XG4gICAgICAgIG0uc2V0KG8ua2V5LCBsKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgbm9vcERhdGFTdGF0ZShjLmRhdGEsIG8ua2V5KTtcbiAgICB9XG4gICAgaWYgKHYpIHtcbiAgICAgIGguc2V0KG8ua2V5LCBvKTtcbiAgICAgIHVwZGF0ZURlcGVuZGVuY2llcyhlLm9wZXJhdGlvbiwgdik7XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICBkYXRhOiBsLFxuICAgICAgZXJyb3I6IHQsXG4gICAgICBleHRlbnNpb25zOiBhLFxuICAgICAgb3BlcmF0aW9uOiBvXG4gICAgfTtcbiAgfTtcbiAgcmV0dXJuIGUgPT4ge1xuICAgIHZhciB0ID0gYShlKTtcbiAgICB2YXIgaSA9IGEobihvcGVyYXRpb25SZXN1bHRGcm9tQ2FjaGUpKG8oKGUgPT4gXCJxdWVyeVwiID09PSBlLmtpbmQgJiYgXCJuZXR3b3JrLW9ubHlcIiAhPT0gZS5jb250ZXh0LnJlcXVlc3RQb2xpY3kpKSh0KSkpO1xuICAgIHZhciBoID0gbygoZSA9PiBcInF1ZXJ5XCIgIT09IGUua2luZCB8fCBcIm5ldHdvcmstb25seVwiID09PSBlLmNvbnRleHQucmVxdWVzdFBvbGljeSkpKHQpO1xuICAgIHZhciBtID0gbigoZSA9PiB7XG4gICAgICBcInByb2R1Y3Rpb25cIiAhPT0gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgJiYgcCh7XG4gICAgICAgIHR5cGU6IFwiY2FjaGVNaXNzXCIsXG4gICAgICAgIG1lc3NhZ2U6IFwiVGhlIHJlc3VsdCBjb3VsZCBub3QgYmUgcmV0cmlldmVkIGZyb20gdGhlIGNhY2hlXCIsXG4gICAgICAgIG9wZXJhdGlvbjogZS5vcGVyYXRpb24sXG4gICAgICAgIHNvdXJjZTogXCJjYWNoZUV4Y2hhbmdlXCJcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIGFkZENhY2hlT3V0Y29tZShlLm9wZXJhdGlvbiwgXCJtaXNzXCIpO1xuICAgIH0pKShvKChlID0+IFwibWlzc1wiID09PSBlLm91dGNvbWUgJiYgXCJjYWNoZS1vbmx5XCIgIT09IGUub3BlcmF0aW9uLmNvbnRleHQucmVxdWVzdFBvbGljeSAmJiAhaXNCbG9ja2VkQnlPcHRpbWlzdGljVXBkYXRlKGUuZGVwZW5kZW5jaWVzKSAmJiAhay5oYXMoZS5vcGVyYXRpb24ua2V5KSkpKGkpKTtcbiAgICB2YXIgTiA9IG4oKGUgPT4ge1xuICAgICAgdmFyIHtvcGVyYXRpb246IHIsIG91dGNvbWU6IHQsIGRlcGVuZGVuY2llczogaX0gPSBlO1xuICAgICAgdmFyIGEgPSB7XG4gICAgICAgIG9wZXJhdGlvbjogYWRkQ2FjaGVPdXRjb21lKHIsIHQpLFxuICAgICAgICBkYXRhOiBlLmRhdGEsXG4gICAgICAgIGVycm9yOiBlLmVycm9yLFxuICAgICAgICBleHRlbnNpb25zOiBlLmV4dGVuc2lvbnNcbiAgICAgIH07XG4gICAgICBpZiAoXCJjYWNoZS1hbmQtbmV0d29ya1wiID09PSByLmNvbnRleHQucmVxdWVzdFBvbGljeSB8fCBcImNhY2hlLWZpcnN0XCIgPT09IHIuY29udGV4dC5yZXF1ZXN0UG9saWN5ICYmIFwicGFydGlhbFwiID09PSB0KSB7XG4gICAgICAgIGEuc3RhbGUgPSAhMDtcbiAgICAgICAgaWYgKCFpc0Jsb2NrZWRCeU9wdGltaXN0aWNVcGRhdGUoaSkpIHtcbiAgICAgICAgICBkLnJlZXhlY3V0ZU9wZXJhdGlvbih0b1JlcXVlc3RQb2xpY3kociwgXCJuZXR3b3JrLW9ubHlcIikpO1xuICAgICAgICB9IGVsc2UgaWYgKFwiY2FjaGUtYW5kLW5ldHdvcmtcIiA9PT0gci5jb250ZXh0LnJlcXVlc3RQb2xpY3kpIHtcbiAgICAgICAgICBfLmFkZChyLmtleSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIFwicHJvZHVjdGlvblwiICE9PSBwcm9jZXNzLmVudi5OT0RFX0VOViAmJiBwKHtcbiAgICAgICAgdHlwZTogXCJjYWNoZUhpdFwiLFxuICAgICAgICBtZXNzYWdlOiBcIkEgcmVxdWVzdGVkIG9wZXJhdGlvbiB3YXMgZm91bmQgYW5kIHJldHVybmVkIGZyb20gdGhlIGNhY2hlLlwiLFxuICAgICAgICBvcGVyYXRpb246IGUub3BlcmF0aW9uLFxuICAgICAgICBkYXRhOiB7XG4gICAgICAgICAgdmFsdWU6IGFcbiAgICAgICAgfSxcbiAgICAgICAgc291cmNlOiBcImNhY2hlRXhjaGFuZ2VcIlxuICAgICAgfSk7XG4gICAgICByZXR1cm4gYTtcbiAgICB9KSkobygoZSA9PiBcIm1pc3NcIiAhPT0gZS5vdXRjb21lIHx8IFwiY2FjaGUtb25seVwiID09PSBlLm9wZXJhdGlvbi5jb250ZXh0LnJlcXVlc3RQb2xpY3kpKShpKSk7XG4gICAgdmFyIEUgPSBhKHIobihwcmVwYXJlRm9yd2FyZGVkT3BlcmF0aW9uKShzKFsgaCwgbSBdKSkpKTtcbiAgICB2YXIgTyA9IG4oKGUgPT4ge1xuICAgICAgdmFyIHIgPSBuZXcgU2V0O1xuICAgICAgdmFyIHQgPSB1cGRhdGVDYWNoZVdpdGhSZXN1bHQoZSwgcik7XG4gICAgICBleGVjdXRlUGVuZGluZ09wZXJhdGlvbnMoZS5vcGVyYXRpb24sIHIpO1xuICAgICAgcmV0dXJuIHQ7XG4gICAgfSkpKG8oKGUgPT4gIWYuaGFzKGUub3BlcmF0aW9uLmtleSkpKShFKSk7XG4gICAgdmFyIHcgPSB2KChlID0+IHtcbiAgICAgIGlmICh5LnB1c2goZSkgPCBmLnNpemUpIHtcbiAgICAgICAgcmV0dXJuIGw7XG4gICAgICB9XG4gICAgICBmb3IgKHZhciByID0gMDsgciA8IHkubGVuZ3RoOyByKyspIHtcbiAgICAgICAgcmVzZXJ2ZUxheWVyKGMuZGF0YSwgeVtyXS5vcGVyYXRpb24ua2V5KTtcbiAgICAgIH1cbiAgICAgIGcuY2xlYXIoKTtcbiAgICAgIHZhciB0ID0gW107XG4gICAgICB2YXIgaSA9IG5ldyBTZXQ7XG4gICAgICB2YXIgYTtcbiAgICAgIHdoaWxlIChhID0geS5zaGlmdCgpKSB7XG4gICAgICAgIHQucHVzaCh1cGRhdGVDYWNoZVdpdGhSZXN1bHQoYSwgaSkpO1xuICAgICAgfVxuICAgICAgZXhlY3V0ZVBlbmRpbmdPcGVyYXRpb25zKGUub3BlcmF0aW9uLCBpKTtcbiAgICAgIHJldHVybiB1KHQpO1xuICAgIH0pKShvKChlID0+IGYuaGFzKGUub3BlcmF0aW9uLmtleSkpKShFKSk7XG4gICAgcmV0dXJuIHMoWyBPLCB3LCBOIF0pO1xuICB9O1xufTtcblxudmFyIGlzT2ZmbGluZUVycm9yID0gZSA9PiBlICYmIGUubmV0d29ya0Vycm9yICYmICFlLnJlc3BvbnNlICYmIChcInVuZGVmaW5lZFwiICE9IHR5cGVvZiBuYXZpZ2F0b3IgJiYgITEgPT09IG5hdmlnYXRvci5vbkxpbmUgfHwgL3JlcXVlc3QgZmFpbGVkfGZhaWxlZCB0byBmZXRjaHxuZXR3b3JrXFxzP2Vycm9yL2kudGVzdChlLm5ldHdvcmtFcnJvci5tZXNzYWdlKSk7XG5cbnZhciBvZmZsaW5lRXhjaGFuZ2UgPSBlID0+IHQgPT4ge1xuICB2YXIge3N0b3JhZ2U6IG59ID0gZTtcbiAgaWYgKG4gJiYgbi5vbk9ubGluZSAmJiBuLnJlYWRNZXRhZGF0YSAmJiBuLndyaXRlTWV0YWRhdGEpIHtcbiAgICB2YXIge2ZvcndhcmQ6IHYsIGNsaWVudDogbCwgZGlzcGF0Y2hEZWJ1ZzogdX0gPSB0O1xuICAgIHZhciB7c291cmNlOiBwLCBuZXh0OiBjfSA9IGQoKTtcbiAgICB2YXIgeSA9IGUub3B0aW1pc3RpYyB8fCB7fTtcbiAgICB2YXIgaCA9IFtdO1xuICAgIHZhciB1cGRhdGVNZXRhZGF0YSA9ICgpID0+IHtcbiAgICAgIHZhciBlID0gW107XG4gICAgICBmb3IgKHZhciByID0gMDsgciA8IGgubGVuZ3RoOyByKyspIHtcbiAgICAgICAgdmFyIHQgPSBoW3JdO1xuICAgICAgICBpZiAoXCJtdXRhdGlvblwiID09PSB0LmtpbmQpIHtcbiAgICAgICAgICBlLnB1c2goe1xuICAgICAgICAgICAgcXVlcnk6IGYodC5xdWVyeSksXG4gICAgICAgICAgICB2YXJpYWJsZXM6IHQudmFyaWFibGVzXG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIG4ud3JpdGVNZXRhZGF0YShlKTtcbiAgICB9O1xuICAgIHZhciBtID0gITE7XG4gICAgdmFyIGZsdXNoUXVldWUgPSAoKSA9PiB7XG4gICAgICBpZiAoIW0pIHtcbiAgICAgICAgbSA9ICEwO1xuICAgICAgICBmb3IgKHZhciBlID0gMDsgZSA8IGgubGVuZ3RoOyBlKyspIHtcbiAgICAgICAgICB2YXIgciA9IGhbZV07XG4gICAgICAgICAgaWYgKFwibXV0YXRpb25cIiA9PT0gci5raW5kKSB7XG4gICAgICAgICAgICBjKGkoXCJ0ZWFyZG93blwiLCByKSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGZvciAodmFyIHQgPSAwOyB0IDwgaC5sZW5ndGg7IHQrKykge1xuICAgICAgICAgIGwucmVleGVjdXRlT3BlcmF0aW9uKGhbdF0pO1xuICAgICAgICB9XG4gICAgICAgIGgubGVuZ3RoID0gMDtcbiAgICAgICAgbSA9ICExO1xuICAgICAgICB1cGRhdGVNZXRhZGF0YSgpO1xuICAgICAgfVxuICAgIH07XG4gICAgbi5vbk9ubGluZShmbHVzaFF1ZXVlKTtcbiAgICBuLnJlYWRNZXRhZGF0YSgpLnRoZW4oKGUgPT4ge1xuICAgICAgaWYgKGUpIHtcbiAgICAgICAgZm9yICh2YXIgdCA9IDA7IHQgPCBlLmxlbmd0aDsgdCsrKSB7XG4gICAgICAgICAgaC5wdXNoKGwuY3JlYXRlUmVxdWVzdE9wZXJhdGlvbihcIm11dGF0aW9uXCIsIHIoZVt0XS5xdWVyeSwgZVt0XS52YXJpYWJsZXMpKSk7XG4gICAgICAgIH1cbiAgICAgICAgZmx1c2hRdWV1ZSgpO1xuICAgICAgfVxuICAgIH0pKTtcbiAgICB2YXIgZyA9IGNhY2hlRXhjaGFuZ2Uoe1xuICAgICAgLi4uZSxcbiAgICAgIHN0b3JhZ2U6IHtcbiAgICAgICAgLi4ubixcbiAgICAgICAgcmVhZERhdGE6ICgpID0+IG4ucmVhZERhdGEoKS5maW5hbGx5KGZsdXNoUXVldWUpXG4gICAgICB9XG4gICAgfSkoe1xuICAgICAgY2xpZW50OiBsLFxuICAgICAgZGlzcGF0Y2hEZWJ1ZzogdSxcbiAgICAgIGZvcndhcmQ6IGUgPT4gbygoZSA9PiB7XG4gICAgICAgIGlmIChcIm11dGF0aW9uXCIgPT09IGUub3BlcmF0aW9uLmtpbmQgJiYgaXNPZmZsaW5lRXJyb3IoZS5lcnJvcikgJiYgKChlLCByKSA9PiB7XG4gICAgICAgICAgdmFyIHQgPSByLnZhcmlhYmxlcyB8fCB7fTtcbiAgICAgICAgICB2YXIgaSA9IGdldEZyYWdtZW50cyhyLnF1ZXJ5KTtcbiAgICAgICAgICB2YXIgYSA9IFsgLi4uZ2V0U2VsZWN0aW9uU2V0KGdldE1haW5PcGVyYXRpb24oci5xdWVyeSkpIF07XG4gICAgICAgICAgdmFyIG47XG4gICAgICAgICAgd2hpbGUgKG4gPSBhLnBvcCgpKSB7XG4gICAgICAgICAgICBpZiAoIXNob3VsZEluY2x1ZGUobiwgdCkpIHtcbiAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKCFpc0ZpZWxkTm9kZShuKSkge1xuICAgICAgICAgICAgICB2YXIgbyA9ICFpc0lubGluZUZyYWdtZW50KG4pID8gaVtnZXROYW1lKG4pXSA6IG47XG4gICAgICAgICAgICAgIGlmIChvKSB7XG4gICAgICAgICAgICAgICAgYS5wdXNoKC4uLmdldFNlbGVjdGlvblNldChvKSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSBpZiAoZVtnZXROYW1lKG4pXSkge1xuICAgICAgICAgICAgICByZXR1cm4gITA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiAhMTtcbiAgICAgICAgfSkoeSwgZS5vcGVyYXRpb24pKSB7XG4gICAgICAgICAgaC5wdXNoKGUub3BlcmF0aW9uKTtcbiAgICAgICAgICB1cGRhdGVNZXRhZGF0YSgpO1xuICAgICAgICAgIHJldHVybiAhMTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gITA7XG4gICAgICB9KSkodihlKSlcbiAgICB9KTtcbiAgICByZXR1cm4gZSA9PiB7XG4gICAgICB2YXIgciA9IGEoZSk7XG4gICAgICB2YXIgdCA9IHMoWyBwLCByIF0pO1xuICAgICAgcmV0dXJuIG8oKGUgPT4ge1xuICAgICAgICBpZiAoXCJxdWVyeVwiID09PSBlLm9wZXJhdGlvbi5raW5kICYmIGlzT2ZmbGluZUVycm9yKGUuZXJyb3IpKSB7XG4gICAgICAgICAgYyh0b1JlcXVlc3RQb2xpY3koZS5vcGVyYXRpb24sIFwiY2FjaGUtb25seVwiKSk7XG4gICAgICAgICAgaC5wdXNoKGUub3BlcmF0aW9uKTtcbiAgICAgICAgICByZXR1cm4gITE7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuICEwO1xuICAgICAgfSkpKGcodCkpO1xuICAgIH07XG4gIH1cbiAgcmV0dXJuIGNhY2hlRXhjaGFuZ2UoZSkodCk7XG59O1xuXG5leHBvcnQgeyBTdG9yZSwgY2FjaGVFeGNoYW5nZSwgb2ZmbGluZUV4Y2hhbmdlLCBxdWVyeSwgd3JpdGUgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXVycWwtZXhjaGFuZ2UtZ3JhcGhjYWNoZS5tanMubWFwXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/@urql/exchange-graphcache/dist/urql-exchange-graphcache.mjs\n"));

/***/ })

});